<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jvms on 云的博客</title>
    <link>https://yunteng9345.github.io/jvm/</link>
    <description>Recent content in Jvms on 云的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 01 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://yunteng9345.github.io/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机网络</title>
      <link>https://yunteng9345.github.io/jvm/review-web/</link>
      <pubDate>Thu, 01 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/review-web/</guid>
      <description>TCP连接的建立（三次握手） -
TCP连接的释放（四次挥手） 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
为什么客户端最后还要等待2MSL？ MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
为什么建立连接是三次握手，关闭连接确是四次挥手呢？
建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
TCP拥塞控制   慢开始
数据窗口从1翻倍增大
  拥塞避免
  快重传
  快恢复
  </description>
    </item>
    
    <item>
      <title>《深入理解JVM》——09.虚拟机字节码执行引擎</title>
      <link>https://yunteng9345.github.io/jvm/jvm-9-jvm-bytecode/</link>
      <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-9-jvm-bytecode/</guid>
      <description>虚拟机字节码执行引擎 概述 所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。
 目录 上一章：JVM性能监控及故障处理命令 下一节：Java字节码  </description>
    </item>
    
    <item>
      <title>《深入理解JVM》——08.虚拟机类加载机制</title>
      <link>https://yunteng9345.github.io/jvm/jvm-8-jvm-run/</link>
      <pubDate>Tue, 05 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-8-jvm-run/</guid>
      <description>虚拟机类加载机制 概述 Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在Java语言里，类型的加载、连接和初始化都是在程序运行期完成的。这种策略让java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一点性能开销，但是却为了Java应用提供了极高的饿扩展性和灵活性，Java天生可以动态扩展的语言特征就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。
类加载的时机 JVM规范严格规定了有且只有6中情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）:
 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这4条指令的典型Java代码场景有：  使用new关键字实例化对象的时候 读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候 调用一个类型的静态方法的时候   使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的的实现类发生了初始化，那该接口要在其之前被初始化。  类加载的过程 加载 在加载阶段，jvm主要完成以下3件事情：
 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表着这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口  可以说，这三点给开发者提供了很多动态的处理方式，如jar包运行、zip文件运行、war等。jsp文件也会被解析生成class文件。还就就是mysql最原始连接时的类加载，就是在程序运行阶段加载的。
验证 目的为了类加载时不要载入有错误或者有恶意企图的字节码使程序崩溃。主要分为以下4个部分：
 文件格式验证，字面意思 元数据验证，对类的元数据信息进行语义验证。 字节码验证，通过数据流分析和控制流分析，确定程序语义是合法的。 符号引用验证，验证类的依赖等资源。  准备 正式为类中的静态变量初始化值或分配内存的时期。这些变量所使用的内存都应该在方法区中进行分配。JDK 8及之后，类变量会随着对象一起存放在Java堆中，这个时候“类变量在方法区”就完全是一种对逻辑概念的表述了。
 说明：代码：public static int value = 123这段代码在准备阶段后value的值是0，并不是123。而 public static final int value = 123这段代码在准备阶段后value的值是123。
 解析 解阶段是jvm将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。
初始化 类的初始化阶段是类加载的最后一个阶段。直到初始化阶段，jvm才开始真正执行类中编写的java程序代码，将主导权移交给应用程序。
类加载器 Java虚拟机有意把类加载阶段中“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类。实现这个动作的代码叫做“类加载器”。
类与类加载器 双亲委派机制 站在虚拟机的角度来看，只存在两种不同的类加载器：
 启动类加载器（是虚拟机自身的一部分，cpp编写） 其他所有的类加载器，java编写，独立存在于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。  应用类加载器（Application Class Loader），也称作“系统类加载器”。它负责加载用户类路径（ClassPath）上所有类库。</description>
    </item>
    
    <item>
      <title>《深入理解JVM》——07.类文件结构</title>
      <link>https://yunteng9345.github.io/jvm/jvm-7-class-struct/</link>
      <pubDate>Mon, 28 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-7-class-struct/</guid>
      <description>类文件结构 概述 不仅仅是Java。任何一种语言，只要将其编译成class文件，即可在jvm中运行。
Class类文件的结构 ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; } Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有任何分隔符。当需要需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。
Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：“无符号数”和“表”。
 无符号数属于基本的数据类型，u1,u2,u4,u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UFT-8编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有的表的命名都习惯地以“_info”结尾。表是用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，  魔数，有趣的东西，用来识别文件是不是java的class文件，因为后缀可以变动，而编译后文件的内容不会变，class文件前4个字节的魔数为COFEBABE，咖啡宝贝。在gif和jpeg文件头中都存在魔数这个东西。后4个字节 存储的是Class文件的版本号。5，6个字节存储的次版本号。
常量池 Class文件主次版本号后面紧接着就是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外它还是Class文件中第一个出现的表类型数据项目，
由于常量池中常量的数量不是固定的，所以在常量池的入口放置了一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。此容量是从1开始的而不是从0，为的是，在特定情况下表达“不引用任何一个的常量池项目”。把索引设置为0来表示。除了此常量池计数器，其他的类型都是从0开始的。
常量池中主要存放2大类常量：字面量和符号引用
 字面量。如文本字符、被声明的final的常量值。 符号引用。编译原理方面的概念。  被模块导出或者开放的包 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 方法句柄和方法类型 动态调用点和动态常量    在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不仅过java虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。
常量池中每一项常量都是一个表，这类表都有一个共同的特点，表结构起始的第一个u1类型的标志位tag，代表着当前常量属于哪种常量类型。后面的name_index市场量池的索引值。我们通过工具javap -verbose XXX.class来分析一个类文件中的常量表的信息。
原始代码：
package com.</description>
    </item>
    
    <item>
      <title>《深入理解JVM》——06.JVM性能监控及故障处理命令</title>
      <link>https://yunteng9345.github.io/jvm/jvm-6-tool/</link>
      <pubDate>Thu, 24 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-6-tool/</guid>
      <description>JVM性能监控及故障处理命令 jps命令(JVM Process Status Tool) jps -l 
输出jvm当前运行的pid及的服务主类的全名，要比ps -ef | grep XXX方便
jps -v 
输出虚拟机进程启动时的JVM参数，超级好用。
jstat命令(JVM Statistics Monitoring Tool) jstat -gcutil $pid
输出java堆各个区域已使用空间占总空间的百分比。E(Eden)、S0(Survivor0)、S1(Survivor1)、O(Old)、P(Permanent)、YGC(Young GC)、YGCT(Young GC Time,单位s)。后面见名思意，自行理解即可。
更新中&amp;hellip;
 目录 上一章：JVM内存分配 下一节：JVM性能监控及故障处理命令  </description>
    </item>
    
    <item>
      <title>《深入理解JVM》——05.JVM内存分配</title>
      <link>https://yunteng9345.github.io/jvm/jvm-5-memery-allocate/</link>
      <pubDate>Mon, 21 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-5-memery-allocate/</guid>
      <description>Java虚拟机内存分配与回收策略 java体系的自动内存管理，最根本的目的是自动化地解决两个问题：
 自动给对象分配内存 自动回收分配给对象的内存  在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下也可能分配在老年代。
对象优先在Eden分配 大多数情况下 ，对象在新生代Eden区中分配。当Eden中没有足够空间进行分配时，虚拟机将发起一次Minor GC。HotSpot虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出时输出当前内存各个区域分配情况。
大对象直接进入老年代 HotSpot虚拟机提供了-XX:PretenureSizeThreshold参数（只对Serial和ParNew两款新生代收集器有效），指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作
长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其的年龄设置成1岁。对象在Survivor区中每熬过；一次Minor GC，年龄增加1岁，当它的年龄增加到一定程度（默认15岁），就会被晋升到老年代中。对对象的晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置
动态对象的判定 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX:MaxTenuringThreshold要求的年龄。
空间分配担保 在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个成立，则虚拟机会先查看-XX:HandkePromotionFailure参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。
 目录 上一章：各类垃圾收集器分析 下一节：JVM性能监控及故障处理命令  </description>
    </item>
    
    <item>
      <title>《深入理解JVM》——04.各类垃圾收集器分析</title>
      <link>https://yunteng9345.github.io/jvm/jvm-4-gcer-detail/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-4-gcer-detail/</guid>
      <description>经典垃圾收集器 如果两个收集器之间存在连线，就说明他们可搭配使用。直到目前为止，也没有万能的收集器，只能是在合适的场景下选择合适的收集器。
Serial收集器 Serial收集器，从名字就可以看出是单线程工作的收集器，但更重要的是强调他在进行垃圾收集时，必须暂停其他所有的工作。“Stop The World”的理解用一个故事就可以说明：你妈在打扫房间的时候，是不是让你在椅子上或者房间外面待着，如果她一遍打扫，你一边扔纸屑，这个房间永远都打扫不干净了。
迄今为止，它依然是HotSpot虚拟机运行在客户端模式下（用户桌面）的默认新生代收集器，与其他单线程收集器比较起来十分简单高效，对于内存资源受限的环境，它是所有收集器里额外内存消（Memory Footprint）最小的。因为它不需要和其他线程进行交互，专心只做一件事情。所以说：Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。
ParNew收集器 ParNew收集器实质上Serial收集器的多线程并行版本，除了使用多线程进行垃圾收集之外，其余行为和控制参数和Serial收集器完全一致。但目前为止只有它能与CMS收集器配合工作。
CMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，**它首次实现了让垃圾收集线程和用户线程（基本上）同时工作。**在JDK5中使用CMS来收集老年代的时候，新生代只能选择Serial收集器和ParNew收集器，而ParNew收集器是激活CMS后（使用-XX:+UseConcMarkSweepGC选项）的默认新生代收集器，也可以使用-XX:+/-UseParNewGC选项来强制指定和禁用。
虽然ParNew十分强大，但随着技术的升级。现在已经被十分NB的G1收集器所取代。G1收集器是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。正所谓：长江后浪推前浪，一代更比一代强，欲知后事如何，请继续看以下讲解的收集器。
Parallel Scavenge收集器 Parallel Scavenge也是一款新生代收集器，它同样是标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，与ParNew非常相似。
Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量（Throughput）。
 吞吐量= {运行用户代码时间} / (运行用户代码时间 + 运行垃圾收集时间)
 Parallel Scavenge收集器提供了俩个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。
 -XX:MaxGCPauseMillis这个值并不是设置的越小越好，因为垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的！
 Serial Old收集器 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法，新生代采用复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程。这个收集器的主要意义也是提供客户端模式下的HotSpot虚拟机使用。 使用场景如下：
 在JDK5以及之前的版本中与Parallel收集器搭配使用 作为CMS收集器发生失败时的后背预案，在并发收集Concurrent Mode Failure时使用  Parallel Old收集器 是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。
CMS收集器(jdk8中重点使用的收集器，我司正在使用) CMS(Concurrent Mark Sweep)收集器是一种以获取最短停顿时间为目标的收集器。因为目前大部分java应用都是基于浏览器的B/S系统的服务端，这类服务较为关注服务的响应速度，希望系统停顿时间尽可能短，已给用户带来友好的体验。
从名字看以看出它是基于标记-清除算法实现的。整个过程分为以下四部分：
 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep）   其中初始标记、重新标记这两个步骤仍然需要“stop the world”。</description>
    </item>
    
    <item>
      <title>《深入理解JVM》——03.垃圾收集器理论</title>
      <link>https://yunteng9345.github.io/jvm/jvm-3-gcer/</link>
      <pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-3-gcer/</guid>
      <description>垃圾收集器算法 因为程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭。所以主要的垃圾收集区域集中在堆区域和方法区，堆里面存放着Java世界中几乎所有对象的实例，垃圾收集器在对堆进行回收之前，第一件事情就是要确认这些对象之中还有哪些“存活”，哪些已经“死去”。
引用计数算法(Reference Counting) 对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用实效时，计数器值减一；任何时刻计数器为零的对象就是不可能再被使用的。但在Java主流的虚拟机里都没有使用引用计数算法来实现垃圾回收，因为它很难解决对象之间相互循环引用的问题。
可达性分析算法(Reachability Analysis) 这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走的路径称为“引用链”(Reference Cain)，如果某个对象到GC Root键没有任何引用链相连，或者用图论的话来说就是从GC Root到这个对象不可达时，则证明此对象是不可能再被使用的。
在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。 在本地方法栈中JNI引用的对象 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如NPE、OOE）等，还有系统类加载器。 所有被同步锁（synchronized）所持有的对象 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。  回收方法区 Java堆中，新生代对常规应用进行一次垃圾回收通常可以回收70%至99%的内存空间。
方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。
 举个例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他的地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也类似。
 判断一个类型是否属于“不在被使用的类”需要同时满足以下三个条件：
 该类所有的实例都已经被回收 加载该类的类加载器已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  垃圾收集算法 分代收集理论 所谓分代收集理论，实质上一套符合大多数程序运行实际情况的经验法则，它建立在俩个分代假说之上
 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集的对象就越难以消灭。  收集器应该将Java堆分成不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储
如果一个区域中大多数对象都是朝生夕灭，我们可以把它们集中在一起，每次回收时只关注如何保留少量存活的对象，而不是去标记那些大量将要被回收的对象，这样就能以较低的代价回收到大量的空间；
如果剩下的都是难以消亡的对象，那把它们集中到一起，虚拟机可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存空间的有效利用。
标记-清除算法（Mark- Sweep） 首先标记出所有需要回收的对象，在标记完成之后，统一回收所有被标记的对象，或者所有未被标记的对象。
 缺点1：效率不稳定，随堆中对象的数量线性增长。
  缺点2：标记-清除后产生大量不连续的内存碎片，分配大对象时无法找到连续的内存不得不提前触发垃圾回收操作。
 标记-复制算法 它将可用内存按容量分为大小相等的两块，没次只使用其中的一块。当这一块的内存用完了，就将存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销。
 缺点：可用内存缩小为原来的一半。
 标记复制算法的进化-Appel式回收 标记-整理算法（Mark Compact） 标记-整理算法，其中的标记过程任然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一段移动，然后直接清理掉边界以外的的内存。
如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存货区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行（Stop The World）</description>
    </item>
    
    <item>
      <title>《深入理解JVM》——02.创建对象过程</title>
      <link>https://yunteng9345.github.io/jvm/jvm-2-new-object-flow/</link>
      <pubDate>Wed, 18 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-2-new-object-flow/</guid>
      <description>Java虚拟机创建对象的过程   jvm遇到第一个new关键字
  检查指令的参数是否能在常量池中定位到一个类的符号引用
  检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，执行相应的类加载过程。
  类加载检查通过后，为新生对象分配内存
 为对象分配空间的任务实际上等同于把一块确定大小的内存从Java堆中划分出来。
   内存分配完成之后，虚拟机将分配到的内存空间都初始化为零值
  jvm对对象进行必要的设置，如：对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息。（这些信息都存在对象头之中，Object Header)
  从虚拟机的视角来看，一个新的对象已经产生。但从java程序的视角来看，对象创建才刚刚开始。
  一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，java编译器会在遇到new关键字的地方同时生成这俩条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行init()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。
  对象的内存布局  Header（对象头） Instance Data （实例数据） Padding （对齐填充）  Header 第一类用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳。信息长度一般在32比特和64比特（针对不同位数虚拟机），官方承它为“Mark Word”。第二类类型指针，即对象指向它的元数据的指针，Java虚拟机通过这个指针来确定该对象是那个类的实例。
Instance Data 对象真正存储的有效信息，程序代码里的定义的各种类型的字段内容，父类和子类的字段都会记录。这部分的存储顺序受到虚拟机分配策略参数（-XX:FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响
Padding 没有特殊含义，仅仅起着占位符的作用
对象的访问定位  句柄访问，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和对象类型数据各自具体的地址信息。 直接指针，reference中存储的直接就是对象地址信息。   目录 上一章：基本概念 下一节：垃圾收集器理论  </description>
    </item>
    
    <item>
      <title>《深入理解JVM》——01.基本概念</title>
      <link>https://yunteng9345.github.io/jvm/jvm-1-base/</link>
      <pubDate>Tue, 17 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://yunteng9345.github.io/jvm/jvm-1-base/</guid>
      <description>Java虚拟机基本概念 JVM运行时数据区域 说明 每开启一个线程JVM都给线程分配三个独立的内存区域，分别是Stack Area（虚拟机栈）、PC Registers（程序计数器）、Native Method Area（本地方法区）。而他们的共享内存区域是Method Area（方法区）、Heap（堆）。
PC Register 程序寄存器，线程执行的字节码的行号指示器，通过改变计数器的值选取下一条执行的字节码指令，控制分支、循环、跳转、异常处理、线程恢复。
 java虚拟机的多线程是通过线程轮换、分配处理器的执行时间的方式来实现的。在任何一个确定的时刻，一个处理器（多核来说也是一个处理器）都只会执行一条线程中的指令。为了每个线程都能恢复到正确的执行位置，所以就有了PC Register。
 Stack Area 虚拟机栈，线程私有，生命周期与线程相同。每个方法被执行的时候，jvm都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息，每个方法被调用直至完成，就对应一个栈帧从入栈到出栈的过程。更多情况下只是指虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种Java虚拟机 基本数据类型（boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它并不等同于对象本身）
Native Method Area 本地方法栈，与虚拟机发挥的作用非常相似，区别：VM Stacks执行Java方法，Native Method Stacks执行本地方法，如：c、cpp等。
 有的虚拟机直接把本地方法栈和虚拟机栈合二为一使用，如Hot-Spot虚拟机
 栈溢出的场景（StackOverflowError）代码
public class TestDemo { private int index = 1; public void method() { index++; method(); } @Test public void testStackOverflowError() { try { method(); } catch (StackOverflowError e) { System.out.println(&amp;#34;程序所需要的栈大小 &amp;gt; 允许最大的栈大小，执行深度: &amp;#34; + index); e.printStackTrace(); } } } java.</description>
    </item>
    
  </channel>
</rss>
