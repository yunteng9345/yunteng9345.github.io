[{"content":"TCP连接的建立（三次握手） -\nTCP连接的释放（四次挥手） 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。\n服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\n为什么客户端最后还要等待2MSL？ MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。\n第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。\n第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。\n为什么建立连接是三次握手，关闭连接确是四次挥手呢？\n建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。\n如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\nTCP拥塞控制  慢开始 拥塞避免 快重传 快恢复  TCP和UDP的区别 UDP不保证可靠性，没有流量控制，基于报文传输，支持一对一、一对多、多对一。\nTCP保可靠传输，支持流量控制，基于字节传输，仅仅支持一对一。\n","date":"2021-04-01T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"计算机网络"},{"content":"数组-解题思路\n","date":"2021-03-04T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%95%B0%E7%BB%84-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/","title":"数组-解题思路"},{"content":"虚拟机字节码执行引擎 概述 所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。\n 目录 上一章：JVM性能监控及故障处理命令 下一节：Java字节码  ","date":"2021-02-05T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm09.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/","title":"《深入理解JVM》——09.虚拟机字节码执行引擎"},{"content":"《Mastering Go》翻译第6章 我的github地址：https://github.com/yunteng9345/Mastering_Go_Second_Edition_Zh_CN\n主要内容：\n go函数开发 匿名函数 多返回值函数 命名函数返回值 函数返回其他函数 可变参数函数 开发Go packages 用Go Modules开发和工作 私有和公有package对象 在packages使用init()函数 Go标准包html/template Go标准包text/template Go高级包go/scanner, go/parser, go/token Go标准包syscall，底层包，虽然你可能不直接使用，但是它广泛运用在其他的Go packages  你不知道的Go packages和功能 上一章讲解了如何开发和如何自定的数据结构，如：linked lists、binary trees、hash table。用Go语言生成随机数和密码、执行高性能的矩阵操作等。\n这章主要的重点是Go packages，它是用Go的方式组织、交付、使用代码。最重要的通用组件就是Go package中的函数，它使得在Go语言中变得可扩展。紧接着，这章将会讲解Go modules，这是带有版本号的Go packages。在这章的最后，你将了解一些属于Go标准库的packages，为了更好的理解Go packages的不同的创建方式。\n本章，你将学到以下主题：\n go函数开发 匿名函数 多返回值函数 命名函数返回值 函数返回其他函数 可变参数函数 开发Go packages 用Go Modules开发和工作 私有和公有package对象 在packages使用init()函数 Go标准包html/template Go标准包text/template Go高级包go/scanner, go/parser, go/token Go标准包syscall，底层包，虽然你可能不直接使用，但是它广泛运用在其他的Go packages  关于Go package 任何内容在Go语言中交付都是以packages的形式。Go package是一个用package关键字开头，后面跟着包名的源文件。一些packages也有结构。例如net包有一系列的子目录，http、mail、rpc、smtp、textproto、url。这些包可以用 net/http, net/mail, net/rpc, net/smtp, net/textproto, net/url 的语法形式单独使用。\n为了和Go标准库做分离，存在一些能够使用全路径导入的外部包，在第一次使用之前会被下载。如github.com/matryer/is，是一个Github仓库。\nPackages主要使用于将函数、变量、 常量分组。为的是在使用自己的Go程序时迁移这些分组更加便捷。注意，除了主要的main package，其他Go packages 程序不能够被编译到可执行文件。这意味着它们需要被main package直接或者间接的引用。如果你执行一个自己的go package（不是main package）。出现如下错误：\n$ go run aPackage.go go run: cannot run non-main package 关于Go函数 函数在任何编程语言中都是非常重要的一环，因为它允许你可以将大的程序分割成更小、更便于管理的部分。函数必须尽可能独立，必须做好一件工作，而且只做好一件工作。所以如果你发现你写一个函数做很多事，应该考虑用多个函数去替换它。（单一职责原则）\nGo语言中最流行的函数就是main()，它是每个独立的Go程序都使用的。你应该已经知道所有的函数定义都以func关键字开头。\n匿名函数 匿名函数被定义在内部，不需要函数名，经常用它来实现一段代码量很少的功能。在Go语言中，函数能够返回一个匿名函数，或者将一个匿名函数作为函数的一个参数，此外，匿名函数能够被附加到Go变量。注意匿名函数也被称为闭包，特别是在函数式编程术语中。\n 对于一个匿名函数来说，需要实现最小的一个重点。如果匿名函数没有重点，你就要考虑将它改造为一个常规的函数。\n 当一个匿名函数只提供一个功能时，它绝对会使你的工作更加简单便捷。只是如果没有合适的场景时，不要在你的程序中使用太多的匿名函数。稍后你将会看到匿名函数的实际使用。\n多返回值函数 如果你已经知道了strconv.Atoi()函数，此函数可以返回多个不同的值，这使您不必为它创建专用的结构 保存函数返回的多个值。你可以定义一个返回4个值的函数，如下\nfunc aFunction() (int, int, float64, string) { } 接下来解释匿名函数和多个返回值的函数，更详细内容使用functions.go文件来说明，用五部分代码来说明。\n第一部分如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) 第二部分代码如下：\nfunc doubleSquare(x int) (int, int) { return x * 2, x * x } 这里有一个doubleSquare()的函数，它传入一个int类型的参数，返回两个int类型的值，第三部分代码如下：\nfunc main() { arguments := os.Args if len(arguments) != 2 { fmt.Println(\u0026#34;The program needs 1 argument!\u0026#34;) return } y, err := strconv.Atoi(arguments[1]) if err != nil { fmt.Println(err) return } 之前的程序是用命令行中附加的参数来处理的。第四部分包含以下内容：\nsquare := func(s int) int { return s * s } fmt.Println(\u0026#34;The square of\u0026#34;, y, \u0026#34;is\u0026#34;, square(y)) double := func(s int) int { return s + s } fmt.Println(\u0026#34;The double of\u0026#34;, y, \u0026#34;is\u0026#34;, double(y)) 每个square和double指向一个匿名函数的地址。不够好的部分是你可以改变square和double的值，或者其他变量在匿名函数定义之后也可以指向该匿名函数的地址。这意味着这些变量能够改变和计算其他内容。\n 改变保存匿名函数的变量代码不是好的编程实践，因为这可能是产生bug的根本原因。\n 最后一部分代码如下：\nfmt.Println(doubleSquare(y)) d, s := doubleSquare(y) fmt.Println(d, s) 所以，你能同时打印函数的返回值，或者将它们分配给其他变量。\n执行functions.go后：\n$ go run functions.go 1 21 The program needs 1 argument! $ go run functions.go 10.2 strconv.Atoi: parsing \u0026#34;10.2\u0026#34;: invalid syntax $ go run functions.go 10 The square of 10 is 100 The double of 10 is 20 20 100 20 100 函数的返回值可以被命名 不像C语言，Go允许将函数的返回值命名。当这样的函数有一个不带任何参数的return语句时，该函数会按照函数定义中声明的顺序自动返回每个命名的返回值的当前值。\nreturnNames.go源码将会说明，已经命名了返回值的函数是怎样工作的。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) func namedMinMax(x, y int) (min, max int) { if x \u0026gt; y { min = y max = x } else { min = x max = y } return } 在这段代码中，可以看到实现了namedMinMax()的函数，它使用了已经命名的返回参数。然而，这里有一个容易出错的地方：namedMinMax()函数在它的return语句中，不能明确的返回一些变量或值。尽管如此，当函数在命名时指定了返回值，min和max参数将按照它们放入函数定义的顺序自动返回。\n第二段代码如下：\nfunc minMax(x, y int) (min, max int) { if x \u0026gt; y { min = y max = x } else { min = x max = y } return min, max } minMax()函数也命名了返回值，但是它的return语句明确定义了返回的顺序和变量。\n最后一部分代码如下：\nfunc main() { arguments := os.Args if len(arguments) \u0026lt; 3 { fmt.Println(\u0026#34;The program needs at least 2 arguments!\u0026#34;) return } a1, _ := strconv.Atoi(arguments[1]) a2, _ := strconv.Atoi(arguments[2]) fmt.Println(minMax(a1, a2)) min, max := minMax(a1, a2) fmt.Println(min, max) fmt.Println(namedMinMax(a1, a2)) min, max = namedMinMax(a1, a2) fmt.Println(min, max) } main()函数的目的是为了验证所有的方法执行的结果是否相同。\n最后一段代码执行后输入如下：\n$ go run returnNames.go -20 1 -20 1 -20 1 -20 1 -20 1 带有指针参数的函数 只要签名允许，函数可以接受指针形参。ptrFun.go将会讲解如何在函数中使用指针。\n第一部分:\npackage main import ( \u0026#34;fmt\u0026#34; ) func getPtr(v *float64) float64 { return *v * *v } getPtr()函数接收一个值指向类型为float64的指针变量。第二部分代码展示如下：\nfunc main() { x := 12.2 fmt.Println(getPtr(\u0026amp;x)) x = 12 fmt.Println(getPtr(\u0026amp;x)) } 比较复杂的部分是函数参数中需要传入变量的地址，因为它是指针参数所需要的类型。通过在变量前加\u0026quot;\u0026amp;\u0026ldquo;符号实现。\n执行ptrFun.go后将生成如下输出：\n$ go run ptrFun.go 148.83999999999997 144 如果想传入一个简单的值到getPtr()函数中调用，类似于getPtr(12.12)。这样程序将会失败，并出现如下错误：\n$ go run ptrFun.go # command-line-arguments ./ptrFun.go:15:21: cannot use 12.12 (type float64) as type *float64 in argument to getPtr 返回指针的函数 从第四章开始，pointerStruct.go文件就用来作为案例代码。对于复合类型的使用，最好的做法是使用单独的函数创建新的结构变量，并从该函数返回指向它们的指针。所以，函数返回指针是很常见的。通常来说，这种函数简化了程序结构，并且允许开发者集中于更多重要的事情上，而不是总是复制一些相同的代码片段。(Ctrl+C和Ctrl+v，造就了一代又一代的程序员，皮一下)。接下来将通过pointerStruct.go的代码来说明本小节的内容。第一部分代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; ) func returnPtr(x int) *int { y := x * x return \u0026amp;y } 这个函数返回了一个指向int变量的指针。唯一的功能就是使用\u0026amp;y返回y变量的内存地址。第二部分如下：\nfunc main() { sq := returnPtr(10) fmt.Println(\u0026#34;sq value:\u0026#34;, *sq) “*”这个符号可以得到指针变量的值，这意味着它返回了一个在内存地址中实际代表的值。（而不是值的地址），最后一段代码如下所示：\nfmt.Println(\u0026#34;sq memory address:\u0026#34;, sq) } 前面的代码将返回sq变量的内存地址。而不是存在其内存中的值。\n如果执行returnPtr.go，你将看到以下输出。不同的内存地址，（因为我们在不同的机器执行，所以变量内存不一定分配在哪一片段）\n$ go run returnPtr.go sq value: 100 sq memory address: 0xc00009a000 返回其他函数的函数 在这个章节中，我们一起学习如何用Go语言实现一个返回其他函数的函数。分为三个部分展示，第一部分returnFunction.go如下：\npackage main import ( \u0026#34;fmt\u0026#34; ) func funReturnFun() func() int { i := 0 return func() int { i++ return i * i } } 我们可以看到funReturnFun()的实现，它的返回值是一个匿名函数function (func() int)。\n第二部分代码如下：\nfunc main() { i := funReturnFun() j := funReturnFun() 在这段代码中，调用funReturnFun()两次，并将其返回值(一个函数)赋给两个独立的变量i和j。我们可以看到程序输出中，这两个变量完全不相关。最后一部分代码如下：\nfmt.Println(\u0026#34;1:\u0026#34;, i()) fmt.Println(\u0026#34;2:\u0026#34;, i()) fmt.Println(\u0026#34;j1:\u0026#34;, j()) fmt.Println(\u0026#34;j2:\u0026#34;, j()) fmt.Println(\u0026#34;3:\u0026#34;, i()) } 在这段代码中，使用i变量3次，j变量2次。但是尽管i和j都是通过funReturnFun()函数被创建。但是他们彼此之间相互独立，没有任何相同之处。\n执行代码后输出：\n$ go run returnFunction.go 1: 1 2: 4 j1: 1 j2: 4 3: 9 从输出内容可以看出，在每一次调用i()或j()之后，i的值保持自增没有变为0，\n将函数作为参数的函数 Go函数能够接受其他Go函数作为其参数，它的特征是能够添加其他Go函数实现的其他用途。两个最常用的功能就是元素排序和filepath.Walk()函数。然而，在展示出的例子中，它被命名为funFun.go。我们将实现最简单的处理int值的例子。有关实现将分为三部分实现。\n第一部分代码如下：\npackage main import \u0026#34;fmt\u0026#34; func function1(i int) int { return i + i } func function2(i int) int { return i * i } 我们有两个函数都接收int返回int。这些函数将在一段时间内被作为其他函数的参数来使用。第二部分代码如下图所示：\nfunc funFun(f func(int) int, v int) int { return f(v) } funFun()函数接收两个参数，一个名为f的函数参数，一个名为v的int参数。f形参应该是一个接受int形参并返回一个int值的函数。最后一部分代码如下：\nfunc main() { fmt.Println(\u0026#34;function1:\u0026#34;, funFun(function1, 123)) fmt.Println(\u0026#34;function2:\u0026#34;, funFun(function2, 123)) fmt.Println(\u0026#34;Inline:\u0026#34;, funFun(func(i int) int {return i * i * i}, 123)) } The first fmt.Println() call uses funFun() with function1, without any parentheses, as its first parameter, whereas the second fmt.Println() call uses funFun() with function2 as its first parameter.\n第一个fmt.Println()调用funFun()，用不带任何圆括号的function1作为第一个形参，而第二个fmt.Println()调用funFun()和function2作为形参。\n最后一个fmt.Println()语句，有趣的事情发生了，函数的实现放在了方法funFun()第一个参数的位置上，尽管这种方法适用于简单和功能小的函数参数。但是对于包含许多行Go代码的函数来说就不那么好了。\n执行代码输出如下：\n$ go run funFun.go function1: 246 function2: 15129 Inline: 1860867 参数可变函数 Go也支持参数可变函数，这些函数能够接收可变的参数个数。最为流行的函数在fmt包中可以找到。接下来通过variadic.go来讲解。将分3部分展示，第一部分如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func varFunc(input ...string) { fmt.Println(input) } 这部分展示了参数可变(变长)函数varFunc()的实现，它接收string类型的可变参数。传入的参数input在函数varFunc()函数内部作为切片使用。而“\u0026hellip;”操作叫做包装操作。而拆包操作以“\u0026hellip;”结尾，以切片类型开始。可以参数函数的包装操作最多一次。第二部分代码如下所示：\nfunc oneByOne(message string, s ...int) int { fmt.Println(message) sum := 0 for i, a := range s { fmt.Println(i, a) sum = sum + a } s[0] = -1000 return sum } 这里你能看到其他可变参数函数oneByOne()，它接收单个string和一个int类型的可变参数。形参s其实就是一个切片。最后一部分代码如下所示：\nfunc main() { arguments := os.Args varFunc(arguments...) sum := oneByOne(\u0026#34;Adding numbers...\u0026#34;, 1, 2, 3, 4, 5, -1, 10) fmt.Println(\u0026#34;Sum:\u0026#34;, sum) s := []int{1, 2, 3} sum = oneByOne(\u0026#34;Adding numbers...\u0026#34;, s...) fmt.Println(s) } main函数中使用了2个可变参数函数。对第二个函数oneByOne()使用了切片。对可变参数函数内的切片所做的任何更改在函数退出后仍将保留。\n执行代码后输出如下：\n$ ./variadic 1 2 [./variadic 1 2] Adding numbers... 0 1 1 2 2 3 3 4 4 5 5 -1 6 10 Sum: 24 Adding numbers... 0 1 1 2 2 3 [-1000 2 3] 开发自己的Go packages Go package的源码，可以包含多个文件和文件夹，能够在以包名命名的单个目录内找到。除了显而易见的main包可以放在任何地方。这章的目标，我们将开发一个名为aPackage的Go package。包的源文件为aPackage.go，它的源码分两部分展示。第一部分如下所示：\npackage aPackage import ( \u0026#34;fmt\u0026#34; ) func A() { fmt.Println(\u0026#34;This is function A!\u0026#34;) } 在Go package中注意使用首写字母大写。在这里的– aPackage仅仅是作为例子在使用。第二部分代码如下：\nfunc B() { fmt.Println(\u0026#34;privateConstant:\u0026#34;, privateConstant) } const MyConstant = 123 const privateConstant = 21 可以看出，开发一个新的Go package非常简单。当前，你不能单独使用这个包，你需要创建一个名为main的包，其中包含main()函数，以便创建一个可执行文件。在这个例子中，将使用aPackage的作为usepackage.go的包名\npackage main import ( \u0026#34;aPackage\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Using aPackage!\u0026#34;) aPackage.A() aPackage.B() fmt.Println(aPackage.MyConstant) } 如果此时执行，会得到以下错误，这意味着我们的程序还没有完成。\n$ go run useAPackage.go useAPackage.go:4:2: cannot find package \u0026#34;aPackage\u0026#34; in any of: /usr/local/Cellar/go/1.9.2/libexec/src/aPackage (from $GOROOT) /Users/mtsouk/go/src/aPackage (from $GOPATH) 这里有另外一件事情需要我们处理。假设你已经知道了第一章的内容和操作系统的知识。Go需要在UNIX中执行一些特殊的shell命令来下载所有的外部包，其中也包含了你本地开发的包。因此，在打包之前你要确保当前的UNIX的用户是可用的，并且将之前的包放在合适的路劲下。因此，下载你自己的包涉及到执行以下UNIX的shell命令：\n$ mkdir ~/go/src/aPackage $ cp aPackage.go ~/go/src/aPackage/ $ go install aPackage $ cd ~/go/pkg/darwin_amd64/ $ ls -l aPackage.a -rw-r--r-- 1 mtsouk staff 4980 Dec 22 06:12 aPackage.a  如果 ~/go 文件夹不是已经存在的, 你将需要用mkdir命令创建一个。在这个例子中。你将需要和 ~/go/src相似的目录，代码执行后如下图所示：\n $ go run useAPackage.go Using aPackage! This is function A! privateConstant: 21 123 编译一个Go package 虽然你不能执行不在main函数内的Go package，但是你仍然可以编译和创建对应的目标文件。如下所示：\n$ go tool compile aPackage.go $ ls -l aPackage.* -rw-r--r--@ 1 mtsouk staff 201 Jan 10 22:08 aPackage.go -rw-r--r-- 1 mtsouk staff 16316 Mar 4 20:01 aPackage.o# 私有变量和函数 私有变量和函数与公共变量和函数的区别在于，私有变量和函数可以在包的内部严格使用和调用。控制哪些函数、常量和变量是公共的，也称为封装。Go使用一个简单的规则区分函数或者变量私有或是共有。公有的函数，变量都是以大写字母开头，相反，私有的函数，变量都是以小写字母开头，这就是fmt.Println()中用Println()而不用println()的原因。然而，这个规则不影响包名的大小写。\ninit() 初始化函数 任何一个Go package能够拥有一个私有函数init()，该函数在其他方法执行之前最开始自动执行。\n init()函数被设计为私有函数，这意味着不能从包外部调用它。作为package的用户不能完全控制init()函数，你应该在使用公共包或在init()函数中修改全局状态时，仔细思考。\n 我们将从多个Go packages中展示一个多个init()函数的例子。案例代码的包名简化为a\npackage a import ( \u0026#34;fmt\u0026#34; ) func init() { fmt.Println(\u0026#34;init() a\u0026#34;) } func FromA() { fmt.Println(\u0026#34;fromA()\u0026#34;) } 这个a包实现了init()函数和一个名为FromA()的函数。在这之后，我们需要使用如下shell命令让这个包成为当前UNIX用户可用的包。\n$ mkdir ~/go/src/a $ cp a.go ~/go/src/a/ $ go install a 现在，我们看下一个Go语言的包b。\npackage b import ( \u0026#34;a\u0026#34; \u0026#34;fmt\u0026#34; ) func init() { fmt.Println(\u0026#34;init() b\u0026#34;) } func FromB() { fmt.Println(\u0026#34;fromB()\u0026#34;) a.FromA() } 这里发生了什么？a包使用了fmt的Go语言标准库。然而，b包需要导入a包才能使用a.FromA()函数。a和b都有一个init()函数。\n在这之后，我们需要下载这个包使得它在当前UNIX用户下可用。执行如下shell脚本。\n$ mkdir ~/go/src/b $ cp b.go ~/go/src/b $ go install b 因此，我们当前有两个包含init()初始话函数的Go packages。现在我们试着猜测下执行manyInit.go后会输出什么，请看以下代码：\npackage main import ( \u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;fmt\u0026#34; ) func init() { fmt.Println(\u0026#34;init() manyInit\u0026#34;) } func main() { a.FromA() b.FromB() } 实际的问题是：在a包执行时init()函数执行了几次？执manyInit.go生成如下输出，并对这个问题给出一些解释:\n$ go run manyInit.go init() a init() b init() manyInit fromA() fromB() fromA() 虽然事实是a包被两个不同的包两次导入，但是之前的输出说明了init()函数只执行了一次。作为从manyInit.go导入的第一次执行的代码块，包a和包b的init()函数在manyInit.go的init()函数之前执行，这比较合理。主要原因是manyInit.go的init()函数允许使用a或b中的元素。\n当你想要设置一些不需要外部使用的内部变量是，init()函数是非常有用的。举例来说，我们可以在init()函数中找到当前的时区。记住，一个文件中可以有多个init()函数；然而，Go的这个特点很少被使用。\nGo modules Go modules在GO 1.11版本中第一次被提及。在写这些内容的时候最新的Go版本是1.13。但在未来的Go版本中，所介绍的一些细节可能会发生变化。\nGo module类似于一个有版本好的Go package。Go对版本控制模块使用语义版本控制。这意味着版本从字母v开头后面加版本号，因此，我们能够有一些类似于v1.0.0, v1.0.5, 和v2.0.2的版本号。\n第一位版本号，v1, v2, or v3代表不向后兼容的Go package的大版本。这意味着如果我们的程序工作在v1版本，它不一定能在v2和v3版本的Go环境下正常工作。第二位版本号是特性相关的，通常v1.1.0版本要比v1.0.2或者v1.0.0有更多的新的特性，也比所有老的版本更加完整。最后一位版本号是和bug fix相关的。没有新的饿特性。注意，语义版本控制也用于Go版本。\n注意Go modules允许我们在GOPATH路径外写一些东西。\nGo module的创建和使用 这部分，我们将创建第一个基础版本的Go module，我们需要一个Github仓库来存储代码。在这部分内容中，代码将放在https://github.com/mactsouk/myModule。我们将创建一个只有README.md的仓库。所以第一次将在shell命令行下执行如下命令：\n$ git clone git@github.com:mactsouk/myModule.git Cloning into \u0026#39;myModule\u0026#39;... remote: Enumerating objects: 7, done. remote: Counting objects: 100% (7/7), done. remote: Compressing objects: 100% (6/6), done. remote: Total 7 (delta 1), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (7/7), done. Resolving deltas: 100% (1/1), done. 执行之后，我们将有一个作者的Github仓库，如果你想从头创建你自己的Go模块，你需要创建你自己的空GitHub仓库。\n创建v1.0.0版本 我们将需要执行如下命令来创建一个我们自己的v1.0.0 Go module。\n$ go mod init go: creating new go.mod: module github.com/mactsouk/myModule $ touch myModule.go $ vi myModule.go $ git add . $ git commit -a -m \u0026#34;Initial version 1.0.0\u0026#34; $ git push $ git tag v1.0.0 $ git push -q origin v1.0.0 $ go list github.com/mactsouk/myModule $ go list -m github.com/mactsouk/myModule myModule.go文件内容如下所示：\npackage myModule import ( \u0026#34;fmt\u0026#34; ) func Version() { fmt.Println(\u0026#34;Version 1.0.0\u0026#34;) } go.mod之前就被创建了，如下：\n$ cat go.mod module github.com/mactsouk/myModule go 1.12 使用v1.0.0版本 在这章中，我们将学习如何使用之前创建的v1.0.0的Go module。为了使用Go modules，我们将创建一个Go程序，useModule.go文件如下所示：\npackage main import ( v1 \u0026#34;github.com/mactsouk/myModule\u0026#34; ) func main() { v1.Version() } 我们需要包含Go module（github.com/mactsouk/myModule）路径。在这例子这个路径的别名为v1。在Go语言中使用别名是不整洁的。为使阅读方便所以使用了别名。虽然如此，这个特征也不推荐用在生产代码中。\n如果我们试着在/tmp路径下执行useModule.go。它将报“找不到github.com/mactsouk/myModule”错误。\n$ pwd /tmp $ go run useModule.go useModule.go:4:2: cannot find package \u0026#34;github.com/mactsouk/myModule\u0026#34; in any of: /usr/local/Cellar/go/1.12/libexec/src/github.com/mactsouk/myModule (from $GOROOT) /Users/mtsouk/go/src/github.com/mactsouk/myModule (from $GOPATH) 因此，我们需要执行如下命令获得Go modules，然后成功执行useModule.go\n$ export GO111MODULE=on $ go run useModule.go go: finding github.com/mactsouk/myModule v1.0.0 go: downloading github.com/mactsouk/myModule v1.0.0 go: extracting github.com/mactsouk/myModule v1.0.0 Version 1.0.0 所以，useModule.go是正确的且能被执行，现在是时候让useModule.go更加规范了。去命名并创建它。\n$ go mod init hello go: creating new go.mod: module hello $ go build 最后一部分命令是在/tmp下生成一个可执行文件，以及两个额外的名为go.mod和go.dum文件。\n$ cat go.sum github.com/mactsouk/myModule v1.0.0 h1:eTCn2Jewnajw0REKONrVhHmeDEJ0Q5TAZ0xsSbh8kFs= github.com/mactsouk/myModule v1.0.0/go.mod h1:s3ziarTDDvaXaHWYYOf/ULi97aoBd6JfnvAkM8rSuzg= go.sum文件的作用是检查所有的module是否已经下载，内容如下所示：\n$ cat go.mod module hello go 1.12 require github.com/mactsouk/myModule v1.0.0  注意如果go.mod文件在我们的项目中制定了v1.3.0 Go module版本，即使有最新版本的Go module可以使用，项目也不会用到最新的Go module。\n 创建v1.1.0版本 在这部分，我们将用不同的tag创建一个新版本的myModule文件。然而，这一次不需要执行命令go mod init，像之前那样。我们将需要执行如下命令：\n$ vi myModule.go $ git commit -a -m \u0026#34;v1.1.0\u0026#34; [master ddd0742] v1.1.0 1 file changed, 1 insertion(+), 1 deletion(-) $ git push $ git tag v1.1.0 $ git push -q origin v1.1.0 myModule.go文件内容如下所示：\npackage myModule import ( \u0026#34;fmt\u0026#34; ) func Version() { fmt.Println(\u0026#34;Version 1.1.0\u0026#34;) } 使用v1.1.0版本 在这章中，我们将学习如何使用我们创建的Go module v1.1.0。这一次，我们将使用Docker镜像，以便尽可能独立用于开发模块的机器。下面的命令会使我们得到Docker镜像然后进入这个程序的运行环境中。\n$ docker run --rm -it golang:latest root@884c0d188694:/go# cd /tmp root@58c5688e3ee0:/tmp# go version go version go1.13 linux/amd64 正如我们所见，Docker镜像使用最新的Go版本，在写本文时就是1.13版本。为了使用一个或多个Go modules。我们将需要创建一个Go程序，命名为useUpdatedModule.go。内容如下：\npackage main import ( v1 \u0026#34;github.com/mactsouk/myModule\u0026#34; ) func main() { v1.Version() } useUpdatedModule.go和useModule.go比较相似。非常棒的一件事情就是我们将自动更新到最新的v1版本。在Docker镜像中写完代码后，我们做如下操作。\nroot@58c5688e3ee0:/tmp# ls -l total 4 -rw-r--r-- 1 root root 91 Mar 2 19:59 useUpdatedModule.go root@58c5688e3ee0:/tmp# export GO111MODULE=on root@58c5688e3ee0:/tmp# go run useUpdatedModule.go go: finding github.com/mactsouk/myModule v1.1.0 go: downloading github.com/mactsouk/myModule v1.1.0 go: extracting github.com/mactsouk/myModule v1.1.0 Version 1.1.0 这意味着useUpdatedModule.go被自动使用最新的v1版本的Go module。当你开启module支持GO111MODULE=on时是比较危险的。\n如果我们尝试执在本地机器上/tmp执行useModule.go时，会得到如下输出：\n$ ls -l go.mod go.sum useModule.go -rw------- 1 mtsouk wheel 67 Mar 2 21:29 go.mod -rw------- 1 mtsouk wheel 175 Mar 2 21:29 go.sum -rw-r--r-- 1 mtsouk wheel 92 Mar 2 21:12 useModule.go $ go run useModule.go Version 1.0.0 这意味着useModule.go依旧使用老版本的Go module。如果想使用最新的Go module，执行如下命令：\n$ rm go.mod go.sum $ go run useModule.go go: finding github.com/mactsouk/myModule v1.1.0 go: downloading github.com/mactsouk/myModule v1.1.0 go: extracting github.com/mactsouk/myModule v1.1.0 Version 1.1.0 如果又想使用v1.0.0的Go module时，执行如下命令：\n$ go mod init hello go: creating new go.mod: module hello $ go build $ go run useModule.go Version 1.1.0 $ cat go.mod module hello go 1.12 require github.com/mactsouk/myModule v1.1.0 $ vi go.mod $ cat go.mod module hello go 1.12 require github.com/mactsouk/myModule v1.0.0 $ go run useModule.go Version 1.0.0 下一章节将会创建一个新Go module的大版本，这意味着用不同的tag代替。我们需要使用一个不同的Github分支。\n创建v2.0.0版本 在这章中，我们将创建一个第二大的myModule版本。注意，对于主要版本，您需要在import语句中明确表示。\n所以github.com/mactsouk/myModule将成为v2版本的github.com/mactsouk/myModule/v2和v3版本的github.com/mactsouk/myModule/v3。第一件事情就是创建一个新的Github分支：\n$ git checkout -b v2 Switched to a new branch \u0026#39;v2\u0026#39; $ git push --set-upstream origin v2 然后输入如下命令：\n$ vi go.mod $ cat go.mod module github.com/mactsouk/myModule/v2 go 1.12 $ git commit -a -m \u0026#34;Using 2.0.0\u0026#34; [v2 5af2269] Using 2.0.0 2 files changed, 2 insertions(+), 2 deletions(-) $ git tag v2.0.0 $ git push --tags origin v2 Counting objects: 4, done. Delta compression using up to 8 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (4/4), 441 bytes | 441.00 KiB/s, done. Total 4 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), completed with 1 local object. To github.com:mactsouk/myModule.git * [new branch] v2 -\u0026gt; v2 * [new tag] v2.0.0 -\u0026gt; v2.0.0 $ git --no-pager branch -a master * v2 remotes/origin/HEAD -\u0026gt; origin/master remotes/origin/master remotes/origin/v2 这个大版本的内容myModule.go如下：\npackage myModule import ( \u0026#34;fmt\u0026#34; ) func Version() { fmt.Println(\u0026#34;Version 2.0.0\u0026#34;) } 使用v2.0.0版本 Once again, in order to use our Go modules, we will need to create a Go program, which is called useV2.go and contains the following Go code:\n为了使用我们的Go module，我们将需要创建一个名为useV2.go的Go程序：\npackage main import ( v \u0026#34;github.com/mactsouk/myModule/v2\u0026#34; ) func main() { v.Version() } 我们将使用Docker镜像。这是最便捷的使用Go module的方式，因为我们会从一个新的go环境下安装。\n$ docker run --rm -it golang:latest root@191d84fc5571:/go# cd /tmp root@191d84fc5571:/tmp# cat \u0026gt; useV2.go package main import ( v \u0026#34;github.com/mactsouk/myModule/v2\u0026#34; ) func main() { v.Version() } root@191d84fc5571:/tmp# export GO111MODULE=on root@191d84fc5571:/tmp# go run useV2.go go: finding github.com/mactsouk/myModule/v2 v2.0.0 go: downloading github.com/mactsouk/myModule/v2 v2.0.0 go: extracting github.com/mactsouk/myModule/v2 v2.0.0 Version 2.0.0 Docker镜像下使用v2.0.0版本的myModule工作正常。\n创建v2.1.0版本 现在我们要创建myModule.go的更新版本。这与使用不同的GitHub标签有关。执行如下命令：\n$ vi myModule.go $ git commit -a -m \u0026#34;v2.1.0\u0026#34; $ git push $ git tag v2.1.0 $ git push -q origin v2.1.0 The updated contents of myModule.go will be as follows:\npackage myModule import ( \u0026#34;fmt\u0026#34; ) func Version() { fmt.Println(\u0026#34;Version 2.1.0\u0026#34;) } 使用v2.1.0版本 我们目前已经知道，为了使用我们的Go module，我们将需要创建一个名为useUpdatedV2.go的Go程序：\npackage main import ( v \u0026#34;github.com/mactsouk/myModule/v2\u0026#34; ) func main() { v.Version() } 这里不需要定义我们想要使用的最新的v2版本的Go module，因为这是由Go处理的，这是使用useUpdatedV2.go的主要原因。useV2.go和它都是一样的。\n使用Docker镜像的原因就是因为它足够简单。使用vcat(1)命令创建useUpdatedV2.go的原因是因为Doker镜像的独立的，其中并没有vi(1)被下载。\n$ docker run --rm -it golang:1.12 root@ccfcd675e333:/go# cd /tmp/ root@ccfcd675e333:/tmp# cat \u0026gt; useUpdatedV2.go package main import ( v \u0026#34;github.com/mactsouk/myModule/v2\u0026#34; ) func main() { v.Version() } root@ccfcd675e333:/tmp# ls -l total 4 -rw-r--r-- 1 root root 92 Mar 2 20:34 useUpdatedV2.go root@ccfcd675e333:/tmp# go run useUpdatedV2.go useUpdatedV2.go:4:2: cannot find package \u0026#34;github.com/mactsouk/myModule/v2\u0026#34; in any of: /usr/local/go/src/github.com/mactsouk/myModule/v2 (from $GOROOT) /go/src/github.com/mactsouk/myModule/v2 (from $GOPATH) root@ccfcd675e333:/tmp# export GO111MODULE=on root@ccfcd675e333:/tmp# go run useUpdatedV2.go go: finding github.com/mactsouk/myModule/v2 v2.1.0 go: downloading github.com/mactsouk/myModule/v2 v2.1.0 go: extracting github.com/mactsouk/myModule/v2 v2.1.0 Version 2.1.0  我们将在第7章反射和接口中学习更多的关于git(1)和Github的命令。\n 一个Go module使用不同的版本 在这章中，我们将学习一个Go module使用的两个以上主要版本。如果你想同时使用一个Go模块的两个以上主要版本，也可以使用相同的技术。\nGo文件useTwo.go如下所示：\npackage main import ( v1 \u0026#34;github.com/mactsouk/myModule\u0026#34; v2 \u0026#34;github.com/mactsouk/myModule/v2\u0026#34; ) func main() { v1.Version() v2.Version() } 所以我们需要明确的导入想使用的不同的版本，并且要给它起别名。\n执行useTwo.go输出如下：\n$ export GO111MODULE=on $ go run useTwo.go go: creating new go.mod: module github.com/PacktPublishing/Mastering-GoSecond-Edition go: finding github.com/mactsouk/myModule/v2 v2.1.0 go: downloading github.com/mactsouk/myModule/v2 v2.1.0 go: extracting github.com/mactsouk/myModule/v2 v2.1.0 Version 1.1.0 Version 2.1.0 Go代码和Go module的存储 在本节中，我们将了解Go如何存储代码和正在使用的Go模块的信息。使用我们的Go module作为一个例子。在我们使用我们的Go module就会生成一些内容在本地的macOS机器的~/go/pkg/mod/github.com/mactsouk文件夹下面。\n$ ls -lR ~/go/pkg/mod/github.com/mactsouk total 0 drwxr-xr-x 3 mtsouk staff 96B Mar 2 22:38 my!module dr-x------ 6 mtsouk staff 192B Mar 2 21:18 my!module@v1.0.0 dr-x------ 6 mtsouk staff 192B Mar 2 22:07 my!module@v1.1.0 /Users/mtsouk/go/pkg/mod/github.com/mactsouk/my!module: total 0 dr-x------ 6 mtsouk staff 192B Mar 2 22:38 v2@v2.1.0 /Users/mtsouk/go/pkg/mod/github.com/mactsouk/my!module/v2@v2.1.0: total 24 -r--r--r-- 1 mtsouk staff 28B Mar 2 22:38 README.md -r--r--r-- 1 mtsouk staff 48B Mar 2 22:38 go.mod -r--r--r-- 1 mtsouk staff 86B Mar 2 22:38 myModule.go /Users/mtsouk/go/pkg/mod/github.com/mactsouk/my!module@v1.0.0: total 24 -r--r--r-- 1 mtsouk staff 28B Mar 2 21:18 README.md -r--r--r-- 1 mtsouk staff 45B Mar 2 21:18 go.mod -r--r--r-- 1 mtsouk staff 86B Mar 2 21:18 myModule.go /Users/mtsouk/go/pkg/mod/github.com/mactsouk/my!module@v1.1.0: total 24 -r--r--r-- 1 mtsouk staff 28B Mar 2 22:07 README.md -r--r--r-- 1 mtsouk staff 45B Mar 2 22:07 go.mod -r--r--r-- 1 mtsouk staff 86B Mar 2 22:07 myModule.go  最好的学习Go module的方式就是去实验尝试（多写多用）。你用或不用，Go module就在那里，所以我们开始使用他们吧。\n go mod vendor命令 有时，我们需要将所有依赖项存储在同一个地方，并将它们保存在项目文件。在这种情况下go mod vendor命令会帮助我们准确的完成：\n$ cd useTwoVersions $ go mod init useV1V2 go: creating new go.mod: module useV1V2 $ go mod vendor $ ls -l total 24 -rw------- 1 mtsouk staff 114B Mar 2 22:43 go.mod -rw------- 1 mtsouk staff 356B Mar 2 22:43 go.sum -rw-r--r--@ 1 mtsouk staff 143B Mar 2 19:36 useTwo.go drwxr-xr-x 4 mtsouk staff 128B Mar 2 22:43 vendor $ ls -l vendor/github.com/mactsouk/myModule total 24 -rw-r--r-- 1 mtsouk staff 28B Mar 2 22:43 README.md -rw-r--r-- 1 mtsouk staff 45B Mar 2 22:43 go.mod -rw-r--r-- 1 mtsouk staff 86B Mar 2 22:43 myModule.go drwxr-xr-x 6 mtsouk staff 192B Mar 2 22:43 v2 $ ls -l vendor/github.com/mactsouk/myModule/v2 total 24 -rw-r--r-- 1 mtsouk staff 28B Mar 2 22:43 README.md -rw-r--r-- 1 mtsouk staff 48B Mar 2 22:43 go.mod -rw-r--r-- 1 mtsouk staff 86B Mar 2 22:43 myModule.go 关键点在于在执行go mod vendor命令之前去执行go mod init \u0026lt;package name\u0026gt;\n创建优秀的Go packages 这章将提供一些好的的建议帮助我们开发更好的Go packages。我们屏蔽Go packages将其组织在文件夹中，能够包含一些共有和私有的元素。公有元素可以在包内部或者包外部使用，私有元素只能在包的内部使用。\n  这里有一些创建go package优秀的规则:第一点非官方的规则就是元素之间必须有一定的关联。因此，你可以创建一个支持car的包，但是创建一个包含有car和bicycles的包就不是那么合理了。简单来说，最好的方式就是将不必要的package放在多个package中，而不是在一个单独的包中添加很多函数。此外，package应该简单和易用，但不能太过于简单和凌乱。（包中功能的粒度不能太小，将同类的功能放一个包中即可）\n  第二部分实际的规则就是我们应该多次使用自己的package，在使用多次没有问题然后在提供给别人使用。这将会帮助我们发现一些愚蠢的bug，确保package的使用是我们预期的结果。在此之后，在公开package之前，将package交给其他开发人员进行额外的测试。\n  紧接着，尝试假设一些愉快地使用我们package的用户类型，确保我们的package在使用过程中，会给他们带来超出他们能力范围的问题。\n  除非我们有很好的理由，否则package不应该输出无穷尽的函数列表。你的package内的很少的函数列表，会使我们很好的理解，使用的方便。在此之后，尝试使用简短的名字命令你的函数名称而不是很长的名字。\n  接口能够提高函数的可用性，所以当我们认为合适的时候，使用接口代替单一类型的函数参数或者返回类型。\n  当更新一个包时，除非绝对必要，尽量不要破坏其他package，也不要创建与旧版本产生不兼容的代码。\n  当开发一个新的Go package时，尝试使用多个文件，为了将相似的任务或者概念分组。\n  此外，尝试仿照标准库的Go package的规则，阅读标准库的代码将会对我们有益。\n  不要创建一个已经在之前存在的package。对现有的包进行更改，并创建自己的版本。\n  没有人想要一个在屏幕上打印日志信息的Go package。在需要用到的时候设置一个日志打开标记来打开日志记录会更专业。\n  在Go代码里引用的Go package使用要和谐。这意味着，如果你看到一个使用你的包和函数名的程序在代码中以一种糟糕的方式出现，最好更改函数的名称。由于package名称几乎在任何地方都被使用，所以尽量使用简洁而富有表现力的包名。\n  如果你将新的Go类型定义放在第一次使用它们的地方附近，会更方便，因为包括您在内的任何人都不希望在源文件中搜索新数据类型的定义。\n  试着在我们的包里创建测试文件，因为有测试文件package比没有的要更加标准，专业。小小的细节将会给使用的人产生很大的便捷，说明你是一个很认真的开发者！请注意，为包编写测试是不是随便的，您应该避免使用不包含测试的包。在11章将学到更多关于测试的内容。\n  最后，不要写Go包，因为你没有更好的事情做-在这种情况下，找一些更好的事情做，不要浪费你的时间!\n   永远记住，除了包中的实际Go代码应该是没有bug的这一事实之外，优秀package中最重要的元素就是它的文档以及一些代码示例,澄清其使用和展示的功能包的特性。\n syscall包 这章将展示一小部分的syscall标准包中函数的使用。注意syscall提供了很多的和操作系统底层相关的函数和类型。此外，syscall包也被很多的Go package使用，类似于os、net、time。这些提供了控制操作系统的一部分接口。这意味着syscall包不是最便捷的Go标准库，这不是它的工作。\n虽然UNIX系统有很多相似之处，他们也展示了各个方面的不同，尤其是我们在谈论操作系统内部时，syscall包尽可能聪明的处理他们之间的不兼容问题。这并不是一个秘密，并且有很好的文档，这使得sycall成为一个成功的包。\n严格来讲，程序调用系统的方式就是应用程序从操作系统内核请求一些内容。可以推断出，系统调用的责任就是存取并执行UNIX下最底层的元素，如程序，存储设备、打印数据，网络接口，任何种类的文件。简单来说，在UNIX系统下不使用系统调用我们将不能工作。我们可以使用一些类似于strace(1) and dtrace(1)的工具来检查UNIX进程的系统调用。这些工具在第2章《理解Go内部》有提到。\nsyscall包的使用将在useSyscall.go中分4个部分说明：\n 你可能不需要直接使用syscall包，除非你的工作的内容偏向于计算机底层。不是所有的Go包对于所有人都是适用的。\n 第一部分代码useSyscall.go如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;syscall\u0026#34; ) 这部分内容导入了程序需要的包，第二部分如下：\nfunc main() { pid, _, _ := syscall.Syscall(39, 0, 0, 0) fmt.Println(\u0026#34;My pid is\u0026#34;, pid) uid, _, _ := syscall.Syscall(24, 0, 0, 0) fmt.Println(\u0026#34;User ID:\u0026#34;, uid) 在这部分，我们将使用的两个方法syscall.Syscall()找到一些关于进程ID和user Id的信息，它的第一个参数决定请求的信息。\n第三部分代码如下：\nmessage := []byte{\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;\\n\u0026#39;} fd := 1 syscall.Write(fd, message) 在这部分，我们将使用syscall.Write()函数在屏幕上打印一些信息。第一个参数是我们将要写的文件描述，第二个参数是承载着实际信息的byte切片。syscall.Write()函数十分便捷。\n最后一部分代码如下：\nfmt.Println(\u0026#34;Using syscall.Exec()\u0026#34;) command := \u0026#34;/bin/ls\u0026#34; env := os.Environ() syscall.Exec(command, []string{\u0026#34;ls\u0026#34;, \u0026#34;-a\u0026#34;, \u0026#34;-x\u0026#34;}, env) } 最后一部分代码，我们将看到如何使用syscall.Exec()函数执行外部命令。然而，我们不能完全控制输入的命令，它是自动打印在屏幕上的。\n在macOS Mojave上执行代码出现如下输出：\n$ go run useSyscall.go My pid is 14602 User ID: 501 Hello! Using syscall.Exec() . .. a.go funFun.go functions.go html.gohtml htmlT.db htmlT.go manyInit.go ptrFun.go returnFunction.go returnNames.go returnPtr.go text.gotext textT.go useAPackage.go useSyscall.go 在 Debian Linux上执行代码出现如下输出：\n$ go run useSyscall.go My pid is 20853 User ID: 0 Hello! Using syscall.Exec() . .. a.go funFun.go functions.go html.gohtml htmlT.db htmlT.go manyInit.go ptrFun.go returnFunction.go returnNames.go returnPtr.go text.gotext textT.go useAPackage.go useSyscall.go 所以，虽然大多数的输出和之前的输出相似，但是syscall.Syscall(39, 0, 0, 0)不能工作在Linux上面，因为在Linux上user id不能为0，这意味着命令不是很便捷。\n如果想要找到Go标准包的syscall，在UNIX shell下执行如下命令：\n$ grep \\\u0026#34;syscall\\\u0026#34; `find /usr/local/Cellar/go/1.12/libexec/src -name \u0026#34;*.go\u0026#34;` 请替换/usr/local/Cellar/go/1.12/libexec/src为合适的路径。\nfmt.Println()是如何工作的 如果你真的想掌握syscall的使用，通过实现fmt.Println()函数(可以在https://golang.org/src/fmt/print.go)中找到。代码如下：\nfunc Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } 这意味着fmt.Println()函数调用了fmt.Fprintln()做了一些工作。fmt.Fprintln()的实现，在同一个文件中可以找到，如下所示：\nfunc Fprintln(w io.Writer, a ...interface{}) (n int, err error) { p := newPrinter() p.doPrintln(a) n, err = w.Write(p.buf) p.free() return } 这意味着在fmt.Fprintln()函数中，实际的去写是通过实现io.Writer接口的Write()函数去写的。在这个例子中。io.Writer的接口是os.Stdout。定义在https://golang.org/src/os/file.go：\nvar ( Stdin = NewFile(uintptr(syscall.Stdin), \u0026#34;/dev/stdin\u0026#34;) Stdout = NewFile(uintptr(syscall.Stdout), \u0026#34;/dev/stdout\u0026#34;) Stderr = NewFile(uintptr(syscall.Stderr), \u0026#34;/dev/stderr\u0026#34;) ) 现在看NewFile()的实现，在ttps://golang.org/src/os/file_plan9.go中可以找到：\nfunc NewFile(fd uintptr, name string) *File { fdi := int(fd) if fdi \u0026lt; 0 { return nil } f := \u0026amp;File{\u0026amp;file{fd: fdi, name: name}} runtime.SetFinalizer(f.file, (*file).close) return f } 当你看到名为file_plan9.go的源文件时，你应该怀疑它是否包含特殊UNIX变体的命令，这意味着它包含的代码不是很便捷。\n我们这里有一个文件结构类型，它嵌入在文件类型中，因为它的名字而被导出。所以，开始在https://golang.org/src/os/file_plan9.go寻找应用在文件结构或者指向文件结构的指针，它允许我们写入数据。作为我们寻找的名为Write()的函数，看Fprintln()的实现，我们将不得不在os包中的所有的源文件中寻找它们。\n$ grep \u0026#34;func (f \\*File) Write(\u0026#34; *.go file.go:func (f *File) Write(b []byte) (n int, err error) { 在https://golang.org/src/os/file.go中Write()的实现如下所示：\nfunc (f *File) Write(b []byte) (n int, err error) { if err := f.checkValid(\u0026#34;write\u0026#34;); err != nil { return 0, err } n, e := f.write(b) if n \u0026lt; 0 { n = 0 } if n != len(b) { err = io.ErrShortWrite } epipecheck(f, e) if e != nil { err = f.wrapErr(\u0026#34;write\u0026#34;, e) } return n, err } 这意味着我们现在不得不寻找write()函数。寻找在https://golang.org/src/os/file_plan9.go中的write string：\nfunc (f *File) write(b []byte) (n int, err error) { if len(b) == 0 { return 0, nil } return fixCount(syscall.Write(f.fd, b)) } 对fmt.Println()函数的调用是使用对syscall.Write()的调用实现的。这说明了syscall包是很重要的。\ngo/scanner, go/parser, 和go/token包 这章将讲解关于go/scanner, go/parser, 和go/token包的内容，和go/ast一样，这是有关Go扫码和解析Go代码的底层知识，可以帮助我们理解Go是如何工作的。然而，如果底层知识太难，你可能想要跳过这一章。\n解析语法需要两个阶段。第一个阶段是将输入分解为标记(词法分析)，第二个阶段是将所有这些标记提供给解析器，以确保这些标记有意义且顺序正确（语法分析）。仅仅结合英语单词并不总能创造出有效的句子。\ngo/ast包 抽象语法树(AST)是Go源代码的结构化表示的程序。这个树是根据语言中指定的一些规则构造的规范。go/ast在go中一般用在定义数据类型。如果你想要找到更多的有关ast.*类型。go/ast包的源码将是你学习的好地方。\ngo/scanner包 扫描器就是一个在程序中能够读取写入的组件。在案例中用来生成token。go/scanner包用于读取go程序并生成一系列token。go/scanner的使用将在goScanner.go中分三部分解释说明。第一部分如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;go/scanner\u0026#34; \u0026#34;go/token\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; ) func main() { if len(os.Args) == 1 { fmt.Println(\u0026#34;Not enough arguments!\u0026#34;) return } go/token包定义了一些Go程序中的表示字典token的常量。第二部分如下：\nfor _, file := range os.Args[1:] { fmt.Println(\u0026#34;Processing:\u0026#34;, file) f, err := ioutil.ReadFile(file) if err != nil { fmt.Println(err) return } One := token.NewFileSet() files := one.AddFile(file, one.Base(), len(f)) 将被标记化的源文件存储在file变量中而其内容存储在f，最后一部分代码如下：\nvar myScanner scanner.Scanner myScanner.Init(files, f, nil, scanner.ScanComments) for { pos, tok, lit := myScanner.Scan() if tok == token.EOF { break } fmt.Printf(\u0026#34;%s\\t%s\\t%q\\n\u0026#34;, one.Position(pos), tok, lit) } } } for循环用来遍历输入的文件。源码中用toker.EOF表示结尾退出for循环。scanner.Scan()函数返回当前文件的下标、token、和文件名。scanner.Init()的scanner.ScanComments的使用告诉扫描器返回token的注解。你可以使用1代替scanner.ScanComments，如果你不想看到token的注解输出，用0代替scanner.ScanComments。build后执行代码如下：\n$ ./goScanner a.go Processing: a.go a.go:1:1 package \u0026#34;package\u0026#34; a.go:1:9 IDENT \u0026#34;a\u0026#34; a.go:1:10 ; \u0026#34;\\n\u0026#34; a.go:3:1 import \u0026#34;import\u0026#34; a.go:3:8 ( \u0026#34;\u0026#34; a.go:4:2 STRING \u0026#34;\\\u0026#34;fmt\\\u0026#34;\u0026#34; a.go:4:7 ; \u0026#34;\\n\u0026#34; a.go:5:1 ) \u0026#34;\u0026#34; a.go:5:2 ; \u0026#34;\\n\u0026#34; a.go:7:1 func \u0026#34;func\u0026#34; a.go:7:6 IDENT \u0026#34;init\u0026#34; a.go:7:10 ( \u0026#34;\u0026#34; a.go:7:11 ) \u0026#34;\u0026#34; a.go:7:13 { \u0026#34;\u0026#34; a.go:8:2 IDENT \u0026#34;fmt\u0026#34; a.go:8:5 . \u0026#34;\u0026#34; a.go:8:6 IDENT \u0026#34;Println\u0026#34; a.go:8:13 ( \u0026#34;\u0026#34; a.go:8:14 STRING \u0026#34;\\\u0026#34;init() a\\\u0026#34;\u0026#34; a.go:8:24 ) \u0026#34;\u0026#34; a.go:8:25 ; \u0026#34;\\n\u0026#34; a.go:9:1 } \u0026#34;\u0026#34; a.go:9:2 ; \u0026#34;\\n\u0026#34; a.go:11:1 func \u0026#34;func\u0026#34; a.go:11:6 IDENT \u0026#34;FromA\u0026#34; a.go:11:11 ( \u0026#34;\u0026#34; a.go:11:12 ) \u0026#34;\u0026#34; a.go:11:14 { \u0026#34;\u0026#34; a.go:12:2 IDENT \u0026#34;fmt\u0026#34; a.go:12:5 . \u0026#34;\u0026#34; a.go:12:6 IDENT \u0026#34;Println\u0026#34; a.go:12:13 ( \u0026#34;\u0026#34; a.go:12:14 STRING \u0026#34;\\\u0026#34;fromA()\\\u0026#34;\u0026#34; a.go:12:23 ) \u0026#34;\u0026#34; a.go:12:24 ; \u0026#34;\\n\u0026#34; a.go:13:1 } \u0026#34;\u0026#34; a.go:13:2 ; \u0026#34;\\n\u0026#34; goScanner.go输出后很简单。注意goScanner.go可以扫描任何类型的文件，即使是二进制文件。然而，如果你扫描二进制文件。你可能得到看不懂的输出。从输出中可以看到，Go扫描器自动加了分隔符。请注意，IDENT通知一个标识符，这是最流行的token类型。\n下一章将处理解析过程\ngo/parser包 解析器读取scanner的输出为了生成这些token的结构。解析器使用语法器描述语法，为了确保给的token是有效的语法。这个结构展示出来如同树的结构，它就是AST。\ngoParser.go说明了处理go/token输出的go/parser包的使用。接下来通过4个部分展示说明：\n第一部分代码如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;go/ast\u0026#34; \u0026#34;go/parser\u0026#34; \u0026#34;go/token\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) type visitor int 第二部分代码如下：\nfunc (v visitor) Visit(n ast.Node) ast.Visitor { if n == nil { return nil } fmt.Printf(\u0026#34;%s%T\\n\u0026#34;, strings.Repeat(\u0026#34;\\t\u0026#34;, int(v)), n) return v + 1 } Visit()函数将被AST的每个Node调用。第三部分代码如下：\nfunc main() { if len(os.Args) == 1 { fmt.Println(\u0026#34;Not enough arguments!\u0026#34;) return } 最后一部分代码如下：\nfor _, file := range os.Args[1:] { fmt.Println(\u0026#34;Processing:\u0026#34;, file) one := token.NewFileSet() var v visitor f, err := parser.ParseFile(one, file, nil, parser.AllErrors) if err != nil { fmt.Println(err) return } ast.Walk(v, f) } } Walk()函数被递归调用，用深度遍历优先遍历AST，访问所有的节点。\nbuilding和执行goParser.go去找到简单又便捷的AST。输出如下：\n$ ./goParser a.go Processing: a.go *ast.File *ast.Ident *ast.GenDecl *ast.ImportSpec *ast.BasicLit *ast.FuncDecl *ast.Ident *ast.FuncType *ast.FieldList *ast.BlockStmt *ast.ExprStmt *ast.CallExpr *ast.SelectorExpr *ast.Ident *ast.Ident *ast.BasicLit *ast.FuncDecl *ast.Ident *ast.FuncType *ast.FieldList *ast.BlockStmt *ast.ExprStmt *ast.CallExpr *ast.SelectorExpr *ast.Ident *ast.Ident *ast.BasicLit goParser.go简单的输出就得到了。然而它和goScanner.go.的输出完全不同。\n现在你已经知道了Go扫描器和Go解析器的输出结果，接下来准备看一些更实用的例子。\n实用案例 在这章中，我们将写一个在输入文件中计算关键字出现次数的Go程序。在这个例子中，关键字为“var”。功能的名字为varTimes.go，它将分4部分展示。第一部分如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;go/scanner\u0026#34; \u0026#34;go/token\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; ) var KEYWORD = \u0026#34;var\u0026#34; var COUNT = 0 你可以搜索任何你想要的Go关键字——如果你修改了varTimes.go，你甚至可以在运行时设置全局关键字变量的值。\nfunc main() { if len(os.Args) == 1 { fmt.Println(\u0026#34;Not enough arguments!\u0026#34;) return } for _, file := range os.Args[1:] { fmt.Println(\u0026#34;Processing:\u0026#34;, file) f, err := ioutil.ReadFile(file) if err != nil { fmt.Println(err) sreturn } one := token.NewFileSet() files := one.AddFile(file, one.Base(), len(f)) 第三部分代码如下：\nvar myScanner scanner.Scanner myScanner.Init(files, f, nil, scanner.ScanComments) localCount := 0 for { _, tok, lit := myScanner.Scan() if tok == token.EOF { break } 在本例中，发现标记的位置被忽略，因为这不重要。但是，要找出文件的结尾，需要使用tok变量。\n最后一部分代码如下：\nif lit == KEYWORD { COUNT++ localCount++ } } fmt.Printf(\u0026#34;Found _%s_ %d times\\n\u0026#34;, KEYWORD, localCount) } fmt.Printf(\u0026#34;Found _%s_ %d times in total\\n\u0026#34;, KEYWORD, COUNT) } 编译执行后varTimes.go输出如下：\n$ go build varTimes.go $ ./varTimes varTimes.go variadic.go a.go Processing: varTimes.go Found _var_ 3 times Processing: variadic.go Found _var_ 0 times Processing: a.go Found _var_ 0 times Found _var_ 3 times in total 查找具有给定字符串长度的变量名 这章将展示其他使用案例，将会比之前在varTimes.go的案例更加高级。你将看到如何查找具有给定字符串长度的变量名，你能使用任何你想要的字符串长度。此外，该程序将能够区分全局变量和局部变量。\n本地变量定义在函数内部，而全局变量定义在函数外部。全局变量也称为包变量。\nThe name of the utility is varSize.go and it will be presented in four parts. The first part of varSize.go is as follows: 名为varSize.go的程序将分为4个部分。第一部分如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;go/ast\u0026#34; \u0026#34;go/parser\u0026#34; \u0026#34;go/token\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strconv\u0026#34; ) var SIZE = 2 var GLOBAL = 0 var LOCAL = 0 type visitor struct { Package map[*ast.GenDecl]bool } func makeVisitor(f *ast.File) visitor { k1 := make(map[*ast.GenDecl]bool) for _, aa := range f.Decls { v, ok := aa.(*ast.GenDecl) if ok { k1[v] = true } } return visitor{k1} } 为了区分本地变量和全局变量之间的关系，我们定义了全局变量GLOBAL和本地变量LOCAL保持他们的计数。visitor结构体的使用将帮助我们区分本地变量和全局变量。因此map字段定义在visitor结构体，makeVisitor()函数的作用是根据参数的值初始化visitor结构体，它是一个代表整个文件的文件节点。第二部分代码的实现如下：\nfunc (v visitor) Visit(n ast.Node) ast.Visitor { if n == nil { return nil } switch d := n.(type) { case *ast.AssignStmt: if d.Tok != token.DEFINE { return v } for _, name := range d.Lhs { v.isItLocal(name) } case *ast.RangeStmt: v.isItLocal(d.Key) v.isItLocal(d.Value) case *ast.FuncDecl: if d.Recv != nil { v.CheckAll(d.Recv.List) } v.CheckAll(d.Type.Params.List) if d.Type.Results != nil { v.CheckAll(d.Type.Results.List) } case *ast.GenDecl: if d.Tok != token.VAR { return v } for _, spec := range d.Specs { value, ok := spec.(*ast.ValueSpec) if ok { for _, name := range value.Names { if name.Name == \u0026#34;_\u0026#34; { continue } if v.Package[d] { if len(name.Name) == SIZE { fmt.Printf(\u0026#34;** %s\\n\u0026#34;, name.Name) GLOBAL++ } } else { if len(name.Name) == SIZE { fmt.Printf(\u0026#34;* %s\\n\u0026#34;, name.Name) LOCAL++ } } } } } } return v } Visit()主要的工作是决定node的类型，以便采取相应的行动。这需要使用到switch语句的帮助。\nast.AssignStmt节点代表作业或者定义的短变量。ast.RangeStmt节点是一种结构类型，用于表示带有range子句的for语句。这是另一个声明新的局部变量的地方。\nast.FuncDecl是一个代表函数定义的结构体类型，被定义在函数内部的每个变量都是本地变量。最后，ast.GenDecl是一个代表import, constant, type或者变量的结构体类型。 然而我们仅仅需要关注在token.VAR里的tokens。第三部分代码如下：\nfunc (v visitor) isItLocal(n ast.Node) { identifier, ok := n.(*ast.Ident) if ok == false { return } if identifier.Name == \u0026#34;_\u0026#34; || identifier.Name == \u0026#34;\u0026#34; { return } if identifier.Obj != nil \u0026amp;\u0026amp; identifier.Obj.Pos() == identifier.Pos() { if len(identifier.Name) == SIZE { fmt.Printf(\u0026#34;* %s\\n\u0026#34;, identifier.Name) LOCAL++ } } } func (v visitor) CheckAll(fs []*ast.Field) { for _, f := range fs { for _, name := range f.Names { v.isItLocal(name) } } } 这两个函数是帮助方法。第一个节点决定标识符节点是否是局部变量，第二个节点访问ast.Field节点检查其内容是否包含局部变量。最后一部分代码如下：\nfunc main() { if len(os.Args) \u0026lt;= 2 { fmt.Println(\u0026#34;Not enough arguments!\u0026#34;) return } temp, err := strconv.Atoi(os.Args[1]) if err != nil { SIZE = 2 fmt.Println(\u0026#34;Using default SIZE:\u0026#34;, SIZE) } else { SIZE = temp } var v visitor all := token.NewFileSet() for _, file := range os.Args[2:] { fmt.Println(\u0026#34;Processing:\u0026#34;, file) f, err := parser.ParseFile(all, file, nil, parser.AllErrors) if err != nil { fmt.Println(err) continue } v = makeVisitor(f) ast.Walk(v, f) } fmt.Printf(\u0026#34;Local: %d, Global:%d with a length of %d.\\n\u0026#34;, LOCAL, GLOBAL, SIZE) } 这程序生成了它输入的AST，为了选出外部需要的信息。分割了Visit()方法，它是接口的一部分，休息的逻辑在main()函数中的ast.Walk()发生，这个函数自动访问了每个文件的所有的AST节点。执行代码生成如下输出：\n$ go build varSize.go $ ./varSize Not enough arguments! $ ./varSize 2 varSize.go variadic.go Processing: varSize.go * k1 * aa * ok * ok * ok * fs Processing: variadic.go Local: 6, Global:0 with a length of 2. $ ./varSize 3 varSize.go variadic.go Processing: varSize.go * err * all * err Processing: variadic.go * sum * sum Local: 5, Global:0 with a length of 3. $ ./varSize 7 varSize.go variadic.go Processing: varSize.go Processing: variadic.go * message Local: 1, Global:0 with a length of 7. 你可以移除一些fmt.Println()调用，这样就会少一些杂乱的输出。\n你现在在Go中做了很聪明的事情，你知道如何解析Go陈序，你甚至可以写出你自己解析器和你自己的语言。如果你真的进入解析，你应该看一眼go/ast这章的内容，它的源码在https://golang.org/pkg/go/ast/和https://github.com/golang/go/tree/master/src/go/ast\nText和HTML模板 这章的主题将会惊艳到你。因为当前展示的包会带给你很大的灵活性，我确信你将会找到创造性的方式去使用它们，模板主要用于分离输出的格式化部分和数据部分。请注意Go模板能够成为文件或者string，一般的想法是对较小的模板使用内联字符串，对较大的模板使用外部文件。\n在Go语言中，不能同时导入text/template和html/template，因为两个包共享相似的包名(template)。如果绝对需要的话，你可以将其中一个起一个别名。在第四章可以看useStrings.go的使用，复合类型的使用。\nText的输出经常展示在你的屏幕上，因此html的输出需要浏览器的帮助。然而，text的输出要比html的输出更好些。如果你认为你将需要使用其他UNIX的命令行工具执行Go工具的输出，你应该用text/template代替html/template\ntext/template和html/template会告诉你Go包有多么复杂。你很快就会看到，这两个包都支持它们自己的编程语言——好的软件使复杂的东西看起来简单而优雅。\n生成text输出 如果需要创建简单的输出，使用text/template包是一个很好的选择。text/templat包将在textT.go文件中分5部分说明。\ntemplate经常存储在外部文件中，例子将展示text.gotext模板文件，将分3个部分分析。数据是在text中或者网络中是类型可读的。然而最简单的原因就是text.gotext文件中的数据被程序使用切片转成硬编码。接下来我们将看textT.go的Go代码。第一部分代码如下所示：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;text/template\u0026#34; ) 第二部分代码如下：\ntype Entry struct { Number int Square int } 你将需要定义一个新的数据类型存储你的数据，除非你处理非常简单的数据。第三部分代码如下：\nfunc main() { arguments := os.Args if len(arguments) != 2 { fmt.Println(\u0026#34;Need the template file!\u0026#34;) return } tFile := arguments[1] DATA := [][]int{{-1, 1}, {-2, 4}, {-3, 9}, {-4, 16}} DATA变量是一个二维切片，用来初始化你的数据的版本。\n第四部分代码如下：\nvar Entries []Entry for _, i := range DATA { if len(i) == 2 { temp := Entry{Number: i[0], Square: i[1]} Entries = append(Entries, temp) } } 这个程序从DATA变量中创建了一个切片的数据结构。\n最后一部分textT.go的代码如下：\nt := template.Must(template.ParseGlob(tFile)) t.Execute(os.Stdout, Entries) } template.Must()用在了初始化。它返回的数据类型是一个Template，它控制一个解析后的展示内容。template.ParseGlob()函数读取外部template文件。注意对于外部template文件我更喜欢使用gohtml扩展。但是你能使用任何你想要的，目的一致就好了。\n最后，template.Execute()函数不能全部工作，它包括执行程序和打印输出到指定的文件，使用os.Stdout。\n现在是时候看一下template文件的代码，第一部分text template如下：\nCalculating the squares of some integers 注意空行在text template文件中也是有效的，它将作为空行在最后的文件中展示出来。\n第二部分代码如下：\n{{ range . }} The square of {{ printf \u0026#34;%d\u0026#34; .Number}} is {{ printf \u0026#34;%d\u0026#34; .Square}} 在这里将会有很多有趣的事情发生。关键字的范围允许你迭代输入的行，作为一个给定的切片结构。简单的text像这样会被打印，因此变量和动态的text必须以“{{”开始以“}}”结束。数据结构的 存取可以用.Number和.Square。注意“.”字符在在这个数据类型的前面。最后,格式化打印命令会将最后的输出文件格式化。\n第三部分代码如下：\n{{ end }} {{ range }}命令以{{ end }}结尾，意外的将{{ end }}放在错误的地方将会影响你的输出。第一次，在text template模板中时刻注意空行的有效性，因为它将会输出在最后的文件中。\nExecuting textT.go will generate the following type of output: 执行textT.go输出如下：\n$ go run textT.go text.gotext Calculating the squares of some integers The square of -1 is 1 The square of -2 is 4 The square of -3 is 9 The square of -4 is 16 构造一个HTML输出 这部分用htmlT.go文件解释说明了html/template的使用。它将分6个部分展示。html/template的哲学和text/template一样。这两个包不同之处在于html/template代码生成HTML的输出时是安全的，不允许代码注入。\n虽然你能用text/template创建HTML输出。毕竟，HTML就是一个简单的text。如果你想创建HTML输出，然后你应该使用html/template代替。\n接下来的内容将从SQLite数据库读取数据，但是你能使用任何你想用的数据库，提供你有的或者你能够写出适当的Go驱动。为了让事情更加简单，案例在读取之前将导入到数据库。\n第一部分如下所示：\npackage main import ( \u0026#34;database/sql\u0026#34; \u0026#34;fmt\u0026#34; _ \u0026#34;github.com/mattn/go-sqlite3\u0026#34; \u0026#34;html/template\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) type Entry struct { Number int Double int Square int } var DATA []Entry var tFile string 你能看出一个导入了一个新包net/http，用来它创建HTTP服务和client服务。你将学到更多的关于网络编程的内容。将在12章学到net和net/httpGo标准库的使用。在13章讲Go语言网络编程的基础——构建你自己的Servers和Client。\n分离出net/http，你能够看到Entry数据类型的定义。它将接收从SQLite数据库表单中查询出得数据。其中也要2个全局变量DATA和\u0026rsquo;tFile'，持有的数据分别被传递到模板文件和模板文件的文件名。\n最后，你可以看https://github.com/mattn/go-sqlite3的使用，通过database/sql接口和SQLite3数据库交互\n第二部分代码如下：\nfunc myHandler(w http.ResponseWriter, r *http.Request) { fmt.Printf(\u0026#34;Host: %s Path: %s\\n\u0026#34;, r.Host, r.URL.Path) myT := template.Must(template.ParseGlob(tFile)) myT.ExecuteTemplate(w, tFile, DATA) } 简单高效的myHandler()函数很惊人，尤其是你考虑函数的大小。template.ExecuteTemplate()函数并不是全都为我们工作。它的第一个参数变量，用来连接HTTP客户端。第二个参数是一个模板文件，这个模板文件用来格式化数据格式，第三个参数是带有数据的结构切片。\n第三部分代码片段如下：\nfunc main() { arguments := os.Args if len(arguments) != 3 { fmt.Println(\u0026#34;Need Database File + Template File!\u0026#34;) return } database := arguments[1] tFile = arguments[2] 第四部分代码如下，这部分你将开始处理数据库。\ndb, err := sql.Open(\u0026#34;sqlite3\u0026#34;, database) if err != nil { fmt.Println(nil) return } fmt.Println(\u0026#34;Emptying database table.\u0026#34;) _, err = db.Exec(\u0026#34;DELETE FROM data\u0026#34;) if err != nil { fmt.Println(nil) return } fmt.Println(\u0026#34;Populating\u0026#34;, database) stmt, _ := db.Prepare(\u0026#34;INSERT INTO data(number, double, square) values(?,?,?)\u0026#34;) for i := 20; i \u0026lt; 50; i++ { _, _ = stmt.Exec(i, 2*i, i*i) } sql.Open()函数连接数据库，用db.Exec()函数，你能执行数据库命令，如果没有异常反馈。最后db.Prepare()函数能够通过它的参数多次处理该表数据，然后调用Exec()函数。\n第五部分代码如下：\nrows, err := db.Query(\u0026#34;SELECT * FROM data\u0026#34;) if err != nil { fmt.Println(nil) return } var n int var d int var s int for rows.Next() { err = rows.Scan(\u0026amp;n, \u0026amp;d, \u0026amp;s) temp := Entry{Number: n, Double: d, Square: s} DATA = append(DATA, temp) } 在这程序这部分，我们使用db.Query()函数和多次调用Next()和Scan()从数据库表单中读取出来数据。循环读取数据，将读取出来的数据放在切片中。现在你已经能够用Go处理数据库了。\n最后一部分用来设置web服务器，它包含如下内容：\nhttp.HandleFunc(\u0026#34;/\u0026#34;, myHandler) err = http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) if err != nil { fmt.Println(err) return } } 这里，http.HandleFunc()函数告诉程序中嵌入的web服务器哪些url将被支持，哪些handler函数(myHandler())支持。当前的handler支持/URL，它是Go匹配所有的URL。这使你不必创建任何额外的静态或动态页面。\nhtmlT.go被分进里了2个虚拟部分中。第一部分将从数据库查询出的数据放到切片中，第二部分就是将数据显示在web服务中。\nSQLite两个最大的优势就是你不需要运行数据库服务，因为SQLite数据库被存储在它自己内部的文件中，这意味着单个文件就是整个数据库。\n注意为了减少Go代码被运行多次的问题，你将需要手动创建数据库表和SQLite3数据库，使用以下命令：\n$ sqlite3 htmlT.db SQLite version 3.19.3 2017-06-27 16:48:08 Enter \u0026#34;.help\u0026#34; for usage hints. sqlite\u0026gt; CREATE TABLE data ( ...\u0026gt; number INTEGER PRIMARY KEY, ...\u0026gt; double INTEGER, ...\u0026gt; square INTEGER ); sqlite\u0026gt; ^D $ ls -l htmlT.db -rw-r--r-- 1 mtsouk staff 8192 Dec 26 22:46 htmlT.db 第一个在UNIX中被执行的shell命令是创建一个数据库文件。第二个命令执行在SQLite3的命令行中创建表和字段，它有3个字段、number、double、square。\n此外，你将需要外部的template文件，它将被命名为html.gohtml，这个文件将被用作生成程序的输出。\nhtml.gohtml的第一部分代码如下：\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Doing Maths in Go!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { font-size: 14px; } table, th, td { border: 2px solid blue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; WEB浏览器将获得的HTML代码基于HTML .gohtml的内容。这意味着你将需要创建适当的HTML输出，因此前面的HTML代码也包括一些内联CSS代码，用于格式化生成的HTML表。\n第二部分代码如下：\n\u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Number\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Double\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Square\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; {{ range . }} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; {{ .Number }} \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; {{ .Double }} \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; {{ .Square }} \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {{ end }} \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; As you can see from the preceding code, you still have to use {{ range }} and {{ end }} in order to iterate over the elements of the slice of structures that was passed to template.ExecuteTemplate(). However, this time the html.gohtml template file contains lots of HTML code in order to format the data in the slice of structures better. 你可以看到之前的代码，你仍然不得不使用{{ range }}和{{ end }}为了遍历切片中的元素值，它通过template.ExecuteTemplate()遍历。然而，这次html.gohtml模板文件包含一些HTML代码为了使数据的数据更加美观。\n最后一部分代码如下：\n\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r最后一部分代码主要是根据HTML标准生成适当的HTML代码。在编译和执行htmlT.go之前，你将需要下载和SQLite3交互的package。执行以下命令：\n$ go get github.com/mattn/go-sqlite3 你已经知道，你可以在~/go/src路径下找到下载的包的源码。如果你是MacOS机器，它的编译版本在~/go/pkg/darwin_amd64下。否则，检查~/go/pkg的内容去找到你自己的架构。注意“~”字符代表当前用户目录的路径。\n注意附加的Go package存在会帮助你和SQLite3数据库交互。然而，这里使用的是目前唯一支持database/sql接口。执行htmlT.go文件会在浏览器看到如下输出：\ngo-module图片go-module.jpg\nhtmlT.go输出\n而且，htmlT.go在UNIX的shell下生成输出的类型，主要有debug信息：\n$ go run htmlT.go htmlT.db html.gohtml Emptying database table. Populating htmlT.db Host: localhost:8080 Path: / Host: localhost:8080 Path: /favicon.ico Host: localhost:8080 Path: /123 如果你想要看到程序从UNIXshell输出HTML,你要使用wget(1)工具：\n$ wget -qO- http://localhost:8080 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Doing Maths in Go!\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; html { font-size: 14px; } table, th, td { border: 2px solid blue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; text/template和html/template都是功能非常强大的包，它能够节省你的时间，所以我建议在你的app有适合的需求时多使用它们。\n资源 你将会在下面找到非常有用的资源：\n  访问syscall标准Go库https://golang.org/pkg/syscall/。这是目前为止我看到过最大的Go文档。\n  访问text/template标准Go库https://golang.org/pkg/text/template/\n  访问html/template标准Go库https://golang.org/pkg/html/template/\n  访问go/token标准Go库https://golang.org/pkg/go/token/\n  访问go/parser标准Go库https://golang.org/pkg/go/parser/\n  访问go/scanner标准Go库https://golang.org/pkg/go/scanner/\n  访问go/ast标准Go库https://golang.org/pkg/go/ast/\n  访问SQLite3https://www.sqlite.org/\n  访问\u0026quot;用Go语言写出最漂亮的package\u0026rdquo;https://www.youtube.com/watch?v=cAWlv2SeQus\n  如果你想知道Plan 9，查看https://plan9.io/plan9/\n  花点时间通过man命令(man 1 find)。查看 find(1) 命令行工具。\n  练习   寻找更多实现fmt.Printf()的信息。\n  你能写一个函数用来存储3个int值吗？尝试写2个版本的函数：一个带有命名返回值，另一个没有命名返回值。你认为哪个更好？\n  你能修改htmlT.go中的代码用text/template代替html/template吗？\n  你能修改htmlT.go中的代码，使用[https://github.com/feyeleanor/gosqlite3](https:// github.com/feyeleanor/gosqlite3)或者https://github.com/phf/go-sqlite3让它和SQLite数据库交互。\n  创建你自己的Go module并且开发针对于它的3个大版本。\n  写一个类似于htmlT.go一样能够读取Mysql数据库的程序。\n  写下你所做的代码更改。\n  总结 这章主要展示了三部分主题：Go functions, Go packages, Go modules.\nGo modules主要的优势是准确的记录依赖信息，它能够重用多模块，让编程变得简单直接。这一章也给你提供了大量的关于开发优秀Go package的建议。随后讲了text/template和html/template包，它允许你创建基于模板的简单的text和html的输出。也有go/token, go/parser, go/scanner这些包。最后，讲了syscall标准Go库的高级特性。\n下一章将要讨论关于Go语言重要的俩个特征：接口和反射。它将讨论OOP、Debug和Go type方法。所有的这些主题都比较高级，在第一次接触你可能感觉他们比较困难。然而学的更多你将成为了一个十分优秀的程序员。\n最后，下一章包括简介git，就是在这章创建Go module的工具git。\n","date":"2021-01-09T00:00:00Z","permalink":"https://yunteng9345.github.io/p/mastering-go%E7%BF%BB%E8%AF%91%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%B7%B2%E5%AE%8C%E6%88%90/","title":"《Mastering Go》翻译第六章（已完成）"},{"content":"2021年12月31日截止：\n30本书(今天是2021年1月4日)：\n10/30\n读完写完读后感，标记x\n 《解密比特币》 《价值：我对投资的思考》 《弃猫：当我谈起父亲时》 《给投资新手的极简股票课》 《这就是OKR:让谷歌、亚马逊实现爆炸性增长的工作法》 《论中国》 《女优》渡边淳一 《支付方法论》 《走进周恩来》 《围城》 《樊登讲论语》 《明朝那些事儿》 《逻辑思维（第五版）》335/1589 《世界上最好玩最有趣的500个冷门知识》 《金庸作品集》141/25491  《射雕英雄传》 《神雕侠侣》 《天龙八部》    《解密比特币》 讲了比特币的来世今生，和现如今的发展趋势，总量是2100万个。优点是全世界互通没有手续费，缺点是受制于政府管控，它并不是一个骗局，而是个天才的发明。由于现在前景不明朗，所以还是观望比较好。本书最后一部分用生动的例子说明了什么是比特币，这本书对于小白来说还是值得一看。\n《价值：我对投资的思考》张磊 高瓴资本创始人张磊写的一本关于价值投资的书，前部分大致讲了他的求学创业史，后部分主要讲了怎么分辨好的企业，总得来讲，其实就是能够实际创建出价值的企业，那么，什么是能够创建出价值的企业呢？能够带动实体经济发展，并且对整个社会和部分人群做出有贡献的事情。后面也讲了些他投了一些什么企业，有点打广告的意思。还有就是投资就是体现人性的过程。其中我最任何的一句话就是：能够被火烧掉的东西都是不值钱的东西，一个人最为重要的就是知识、能力、价值观。\n《弃猫：当我谈起父亲时》村上春树 村上回忆父亲的杂记，讲了父亲年轻时的事情，以及战争带来的危害。可以看出村上花了很多时间去调查他已过世父亲的生平。书很短，在微信读书只有80页左右，所以没怎么看就看完了。\n《给投资新手的极简股票课》 这本书是我目前看到的有关股票入门的最好的一本书。通过三个人的故事来讲股票的基本概念和简单的投资理论娓娓道来。作者结合投资的理念看待人生，可以看出作者对人生已经看得比较透彻。总之我很喜欢的一本书，作者是——lip师兄\n《这就是OKR:让谷歌、亚马逊实现爆炸性增长的工作法》 简单概括：让所有同事确定一个共同的目标，做事有结果，没有结果等于没做。在实行OKR的同时最好以季度为周期，根据实际情况进行调整。\n《论中国》基辛格 美国人眼中的中国社会演变，其中有历届领导人的执政重点的介绍。\n《女优》渡边淳一 一段罗曼史，一个大学教授和女优的爱情故事，这个女优在日本就是演员的意思，并不是AV女优。岛村抱月是导演，须磨子是演员。抱月是有妻女的。整个故事在看来比较平淡，就是出轨。结局很亮，抱月 因为西班牙流感去世了，而须磨子之前根本不把他放在心上，仅仅是性的关系，而他去世后，须磨子慢慢觉得她是很爱他的。然后在经常排练的地方上吊自杀。太凄惨了。。。\n《支付方法论》 一本讲解支付的，作者是在支付行业工作将近10年。所以我觉的里面有很多内容是非常有用的。举个栗子，如果给一个外行讲解支付主要做什么？有个例子很好的 说明情况：老王有2只鸡，老李有1只羊，老王想用鸡换老李的羊，他的这个想法就是“交易”。因为羊和鸡的价值并不是等价的，所以老李需要用2只鸡换老王的1只羊， 其实这个等价换算的过程就叫做清算。最后，老李得到了老王的2只鸡，老王得到的老李的1只羊，这个过程就是结算。\n在支付公司待了将近2年，每天的工作无外乎都是从这件事情演变出来的。所以看到这个例子觉得很贴切，但如果以专业的角度来说的，就不那么完整了。\n《走进周恩来》 讲周总理的书，分了很多切入点去讲述总理的生活，工作。周总理真的是一个有信仰有信念的伟人，勤勤恳恳，任劳任怨，十分节俭。可以说他真的是为了人民过上更好的生活累死的！ 令我印象最深的一章就是——6个办公室。用今天的话来讲，第一个办公室就是卫生间，他从不浪费一分一秒，包括走路都是非常快，为的就是节约时间多为祖国做些事情。毛主席和周恩来的 区别其实十分明显，毛主席只负责指导大方向，因为他不仅仅是军事家，文学家，也是一个哲学家。他思考问题的方式是从非常宏观的角度讲的，所以这导致于总理要负责很多基础性的工作， 很多事情必须得他批准才能去落地。\n总书看下来，其实我认为一个人最为重要的就是信念，只要信念足够强大，没有什么事情是做不到的！\n《围城》 讽刺小说，和我想象中的这本书不一样，后半部分讲了婚姻想围城，城里的人想出去，城外的人想进去。这本书的故事就是一个鸿渐和几个女人的故事，说实话没怎么看明白。文字也不是白话文，是我文学素养不够。\n","date":"2021-01-06T00:00:00Z","permalink":"https://yunteng9345.github.io/p/2021%E5%B9%B4%E8%AE%A1%E5%88%92/","title":"2021年计划"},{"content":"————摘自https://github.com/unknwon/the-way-to-go_ZH_CN\n2.2 Go 环境变量 Go 开发环境依赖于一些操作系统环境变量，你最好在安装 Go 之前就已经设置好他们。如果你使用的是 Windows 的话，你完全不用进行手动设置，Go 将被默认安装在目录 c:/go 下。这里列举几个最为重要的环境变量：\n $GOROOT 表示 Go 在你的电脑上的安装位置，它的值一般都是 $HOME/go，当然，你也可以安装在别的地方。 $GOARCH 表示目标机器的处理器架构，它的值可以是 386、amd64 或 arm。 $GOOS 表示目标机器的操作系统，它的值可以是 darwin、freebsd、linux 或 windows。 $GOBIN 表示编译器和链接器的安装位置，默认是 $GOROOT/bin，如果你使用的是 Go 1.0.3 及以后的版本，一般情况下你可以将它的值设置为空，Go 将会使用前面提到的默认值。  目标机器是指你打算运行你的 Go 应用程序的机器。\nGo 编译器支持交叉编译，也就是说你可以在一台机器上构建运行在具有不同操作系统和处理器架构上运行的应用程序，也就是说编写源代码的机器可以和目标机器有完全不同的特性（操作系统与处理器架构）。\n为了区分本地机器和目标机器，你可以使用 $GOHOSTOS 和 $GOHOSTARCH 设置本地机器的操作系统名称和编译体系结构，这两个变量只有在进行交叉编译的时候才会用到，如果你不进行显示设置，他们的值会和本地机器（$GOOS 和 $GOARCH）一样。\n $GOPATH 默认采用和 $GOROOT 一样的值，但从 Go 1.1 版本开始，你必须修改为其它路径。它可以包含多个 Go 语言源码文件、包文件和可执行文件的路径，而这些路径下又必须分别包含三个规定的目录：src、pkg 和 bin，这三个目录分别用于存放源码文件、包文件和可执行文件。 $GOARM 专门针对基于 arm 架构的处理器，它的值可以是 5 或 6，默认为 6。 $GOMAXPROCS 用于设置应用程序可使用的处理器个数与核数，详见第 14.1.3 节。  在接下来的章节中，我们将会讨论如何在 Linux、Mac OS X 和 Windows 上安装 Go 语言。在 FreeBSD 上的安装和 Linux 非常类似。开发团队正在尝试将 Go 语言移植到其它例如 OpenBSD、DragonFlyBSD、NetBSD、Plan 9、Haiku 和 Solaris 操作系统上，你可以在这个页面找到最近的动态：Go Porting Efforts。\n链接  目录 上一节：平台与架构 下一节：  ","date":"2021-01-06T00:00:00Z","permalink":"https://yunteng9345.github.io/p/go%E8%AF%AD%E8%A8%80go-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"go语言《Go 环境变量》"},{"content":"【面经】字节北京抖音直播后端面经-已OC\n面经内容\nImage\n【一面】\n1.自我介绍\n2.问项目\n3.redis的服务量级\n4.redis热点问题怎么解决\n5.java gc\n6.java内存区域？new对象在哪？局部变量在哪？gc发生在哪？\n7.java synchronized，volatile还有reentrantLock的底层原理\n8.Atomic\n9.线程同步的方式\n10.线程之间共享的有什么\n11.进程和线程的区别\n12.进程间通信的方式\n13.共享内存的实现方式？shmset，shmat\n14.如何结束一个进程？kill底层发生了什么（信号）\n15.用户态和内核态的区别\n16.用户态什么情况下会陷入内核态\n17.tcp和udp的区别\n18.tcp拥塞控制\n19.time_wait的作用\n20.算法题：\n问得中规中矩\n【二面】\n1.自我介绍\n2.问项目\n3.项目中遇到的最大的挑战？\n4.用到的Go的特性？channel\n5.进程和线程 线程和协程的区别\n6.段页式存储\n7.逻辑地址和物理地址的转化\n8.输入一个用https协议的url到呈现出页面的过程\n9.详细说下ssl连接的建立过程\n10.算法题：\n  LRU Cache的实现 复杂度O(1) 口头描述\n  K个一组翻转链表\n  11.聊天：平时怎么学技术知识？有系统看书吗？最近在看啥书？\n不知道为啥，问得好像有点少。\n不能说面试常考LRU吧，只能说这题每一次都遇到。\n【三面】\n1.自我介绍\n2.聊项目\n3.设计关注和被关注的功能，怎么存储\n4.mongodb和mysql的区别\n5.redis持久化\n6.rdb bgsave的时候存储的数据是拷贝给子进程的吗\n7.算法题：实现除法，对整数a，b，若为无限循环小数则用括号标出循环结。比如1/2=0.5，1/3=0.(3) ，1/12=0.8(3)\n8.TCP的建立连接和断开连接的过程\n9.TCP为什么四次挥手\n","date":"2021-01-06T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%94%B6%E9%9B%86%E9%97%AE%E9%A2%98/","title":"收集问题"},{"content":"虚拟机类加载机制 概述 Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。与那些在编译时需要进行连接的语言不同，在Java语言里，类型的加载、连接和初始化都是在程序运行期完成的。这种策略让java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一点性能开销，但是却为了Java应用提供了极高的饿扩展性和灵活性，Java天生可以动态扩展的语言特征就是依赖运行期动态加载和动态连接这个特点实现的。例如，编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或其他地方上加载一个二进制流作为其程序代码的一部分。\n类加载的时机 JVM规范严格规定了有且只有6中情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）:\n 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这4条指令的典型Java代码场景有：  使用new关键字实例化对象的时候 读取或设置一个类型的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候 调用一个类型的静态方法的时候   使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的的实现类发生了初始化，那该接口要在其之前被初始化。  类加载的过程 加载 在加载阶段，jvm主要完成以下3件事情：\n 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表着这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口  可以说，这三点给开发者提供了很多动态的处理方式，如jar包运行、zip文件运行、war等。jsp文件也会被解析生成class文件。还就就是mysql最原始连接时的类加载，就是在程序运行阶段加载的。\n验证 目的为了类加载时不要载入有错误或者有恶意企图的字节码使程序崩溃。主要分为以下4个部分：\n 文件格式验证，字面意思 元数据验证，对类的元数据信息进行语义验证。 字节码验证，通过数据流分析和控制流分析，确定程序语义是合法的。 符号引用验证，验证类的依赖等资源。  准备 正式为类中的静态变量初始化值或分配内存的时期。这些变量所使用的内存都应该在方法区中进行分配。JDK 8及之后，类变量会随着对象一起存放在Java堆中，这个时候“类变量在方法区”就完全是一种对逻辑概念的表述了。\n 说明：代码：public static int value = 123这段代码在准备阶段后value的值是0，并不是123。而 public static final int value = 123这段代码在准备阶段后value的值是123。\n 解析 解阶段是jvm将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或者接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。\n初始化 类的初始化阶段是类加载的最后一个阶段。直到初始化阶段，jvm才开始真正执行类中编写的java程序代码，将主导权移交给应用程序。\n类加载器 Java虚拟机有意把类加载阶段中“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类。实现这个动作的代码叫做“类加载器”。\n类与类加载器 双亲委派机制 站在虚拟机的角度来看，只存在两种不同的类加载器：\n 启动类加载器（是虚拟机自身的一部分，cpp编写） 其他所有的类加载器，java编写，独立存在于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。  应用类加载器（Application Class Loader），也称作“系统类加载器”。它负责加载用户类路径（ClassPath）上所有类库。\n 目录 上一章：JVM性能监控及故障处理命令 下一节：Java字节码  ","date":"2021-01-05T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm08.%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","title":"《深入理解JVM》——08.虚拟机类加载机制"},{"content":"类文件结构 概述 不仅仅是Java。任何一种语言，只要将其编译成class文件，即可在jvm中运行。\nClass类文件的结构 ClassFile { u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; } Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有任何分隔符。当需要需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。\nClass文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种结构只有两种数据类型：“无符号数”和“表”。\n 无符号数属于基本的数据类型，u1,u2,u4,u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UFT-8编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的符合数据类型，所有的表的命名都习惯地以“_info”结尾。表是用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，  魔数，有趣的东西，用来识别文件是不是java的class文件，因为后缀可以变动，而编译后文件的内容不会变，class文件前4个字节的魔数为COFEBABE，咖啡宝贝。在gif和jpeg文件头中都存在魔数这个东西。后4个字节 存储的是Class文件的版本号。5，6个字节存储的次版本号。\n常量池 Class文件主次版本号后面紧接着就是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外它还是Class文件中第一个出现的表类型数据项目，\n由于常量池中常量的数量不是固定的，所以在常量池的入口放置了一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。此容量是从1开始的而不是从0，为的是，在特定情况下表达“不引用任何一个的常量池项目”。把索引设置为0来表示。除了此常量池计数器，其他的类型都是从0开始的。\n常量池中主要存放2大类常量：字面量和符号引用\n 字面量。如文本字符、被声明的final的常量值。 符号引用。编译原理方面的概念。  被模块导出或者开放的包 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 方法句柄和方法类型 动态调用点和动态常量    在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不仅过java虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。\n常量池中每一项常量都是一个表，这类表都有一个共同的特点，表结构起始的第一个u1类型的标志位tag，代表着当前常量属于哪种常量类型。后面的name_index市场量池的索引值。我们通过工具javap -verbose XXX.class来分析一个类文件中的常量表的信息。\n原始代码：\npackage com.taifung.qrcode.chn.bocpay; import com.jlpay.commons.tools.SpringContextUtil; import lombok.extern.slf4j.Slf4j; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Import; import org.springframework.http.client.SimpleClientHttpRequestFactory; import org.springframework.web.client.RestTemplate; /** * @description 中国银行澳门分行 * @date 11:24 2020/9/8 * @author Mr.Cloud **/ @Slf4j @EnableDiscoveryClient @SpringBootApplication @ComponentScan(basePackages = {\u0026#34;com.jlpay.commons.rpc.thrift.referer.zookeeper\u0026#34;, \u0026#34;com.jlpay.commons.rpc.thrift.referer.service\u0026#34;, \u0026#34;com.jlpay.commons.rpc.thrift.server\u0026#34;, \u0026#34;com.taifung.qrcode.chn.bocpay\u0026#34;}) @Import(SpringContextUtil.class) public class BocPayBootstrap { public static void main(String[] args) { log.info(\u0026#34;starting qrcode channel of BocPay server\u0026#34;); SpringApplication.run(BocPayBootstrap.class, args); log.info(\u0026#34;qrcode channel of BocPay server start ok\u0026#34;); } @Bean public RestTemplate restTemplate() { SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory(); clientHttpRequestFactory.setConnectTimeout(20000); clientHttpRequestFactory.setReadTimeout(20000); return new RestTemplate(clientHttpRequestFactory); } } 使用命令javap -verbose BocPayBootstrap.class后\nLast modified 2020-12-17; size 2172 bytes MD5 checksum 2c81850e316de50d35699eaee10d44dc Compiled from \u0026#34;BocPayBootstrap.java\u0026#34; public class com.taifung.qrcode.chn.bocpay.BocPayBootstrap minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #15.#50 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V  #2 = Fieldref #5.#51 // com/taifung/qrcode/chn/bocpay/BocPayBootstrap.log:Lorg/slf4j/Logger;  #3 = String #52 // starting qrcode channel of BocPay server  #4 = InterfaceMethodref #53.#54 // org/slf4j/Logger.info:(Ljava/lang/String;)V  #5 = Class #55 // com/taifung/qrcode/chn/bocpay/BocPayBootstrap  #6 = Methodref #56.#57 // org/springframework/boot/SpringApplication.run:(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext;  #7 = String #58 // qrcode channel of BocPay server start ok  #8 = Class #59 // org/springframework/http/client/SimpleClientHttpRequestFactory  #9 = Methodref #8.#50 // org/springframework/http/client/SimpleClientHttpRequestFactory.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V  #10 = Methodref #8.#60 // org/springframework/http/client/SimpleClientHttpRequestFactory.setConnectTimeout:(I)V  #11 = Methodref #8.#61 // org/springframework/http/client/SimpleClientHttpRequestFactory.setReadTimeout:(I)V  #12 = Class #62 // org/springframework/web/client/RestTemplate  #13 = Methodref #12.#63 // org/springframework/web/client/RestTemplate.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:(Lorg/springframework/http/client/ClientHttpRequestFactory;)V  #14 = Methodref #64.#65 // org/slf4j/LoggerFactory.getLogger:(Ljava/lang/Class;)Lorg/slf4j/Logger;  #15 = Class #66 // java/lang/Object  #16 = Utf8 log #17 = Utf8 Lorg/slf4j/Logger; #18 = Utf8 \u0026lt;init\u0026gt; #19 = Utf8 ()V #20 = Utf8 Code #21 = Utf8 LineNumberTable #22 = Utf8 LocalVariableTable #23 = Utf8 this #24 = Utf8 Lcom/taifung/qrcode/chn/bocpay/BocPayBootstrap; #25 = Utf8 main #26 = Utf8 ([Ljava/lang/String;)V #27 = Utf8 args #28 = Utf8 [Ljava/lang/String; #29 = Utf8 MethodParameters #30 = Utf8 restTemplate #31 = Utf8 ()Lorg/springframework/web/client/RestTemplate; #32 = Utf8 clientHttpRequestFactory #33 = Utf8 Lorg/springframework/http/client/SimpleClientHttpRequestFactory; #34 = Utf8 RuntimeVisibleAnnotations #35 = Utf8 Lorg/springframework/context/annotation/Bean; #36 = Utf8 \u0026lt;clinit\u0026gt; #37 = Utf8 SourceFile #38 = Utf8 BocPayBootstrap.java #39 = Utf8 Lorg/springframework/cloud/client/discovery/EnableDiscoveryClient; #40 = Utf8 Lorg/springframework/boot/autoconfigure/SpringBootApplication; #41 = Utf8 Lorg/springframework/context/annotation/ComponentScan; #42 = Utf8 basePackages #43 = Utf8 com.jlpay.commons.rpc.thrift.referer.zookeeper #44 = Utf8 com.jlpay.commons.rpc.thrift.referer.service #45 = Utf8 com.jlpay.commons.rpc.thrift.server #46 = Utf8 com.taifung.qrcode.chn.bocpay #47 = Utf8 Lorg/springframework/context/annotation/Import; #48 = Utf8 value #49 = Utf8 Lcom/jlpay/commons/tools/SpringContextUtil; #50 = NameAndType #18:#19 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V  #51 = NameAndType #16:#17 // log:Lorg/slf4j/Logger;  #52 = Utf8 starting qrcode channel of BocPay server #53 = Class #67 // org/slf4j/Logger  #54 = NameAndType #68:#69 // info:(Ljava/lang/String;)V  #55 = Utf8 com/taifung/qrcode/chn/bocpay/BocPayBootstrap #56 = Class #70 // org/springframework/boot/SpringApplication  #57 = NameAndType #71:#72 // run:(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext;  #58 = Utf8 qrcode channel of BocPay server start ok #59 = Utf8 org/springframework/http/client/SimpleClientHttpRequestFactory #60 = NameAndType #73:#74 // setConnectTimeout:(I)V  #61 = NameAndType #75:#74 // setReadTimeout:(I)V  #62 = Utf8 org/springframework/web/client/RestTemplate #63 = NameAndType #18:#76 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:(Lorg/springframework/http/client/ClientHttpRequestFactory;)V  #64 = Class #77 // org/slf4j/LoggerFactory  #65 = NameAndType #78:#79 // getLogger:(Ljava/lang/Class;)Lorg/slf4j/Logger;  #66 = Utf8 java/lang/Object #67 = Utf8 org/slf4j/Logger #68 = Utf8 info #69 = Utf8 (Ljava/lang/String;)V #70 = Utf8 org/springframework/boot/SpringApplication #71 = Utf8 run #72 = Utf8 (Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext; #73 = Utf8 setConnectTimeout #74 = Utf8 (I)V #75 = Utf8 setReadTimeout #76 = Utf8 (Lorg/springframework/http/client/ClientHttpRequestFactory;)V #77 = Utf8 org/slf4j/LoggerFactory #78 = Utf8 getLogger #79 = Utf8 (Ljava/lang/Class;)Lorg/slf4j/Logger; { public com.taifung.qrcode.chn.bocpay.BocPayBootstrap(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V  4: return LineNumberTable: line 25: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lcom/taifung/qrcode/chn/bocpay/BocPayBootstrap; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field log:Lorg/slf4j/Logger;  3: ldc #3 // String starting qrcode channel of BocPay server  5: invokeinterface #4, 2 // InterfaceMethod org/slf4j/Logger.info:(Ljava/lang/String;)V  10: ldc #5 // class com/taifung/qrcode/chn/bocpay/BocPayBootstrap  12: aload_0 13: invokestatic #6 // Method org/springframework/boot/SpringApplication.run:(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext;  16: pop 17: getstatic #2 // Field log:Lorg/slf4j/Logger;  20: ldc #7 // String qrcode channel of BocPay server start ok  22: invokeinterface #4, 2 // InterfaceMethod org/slf4j/Logger.info:(Ljava/lang/String;)V  27: return LineNumberTable: line 28: 0 line 29: 10 line 30: 17 line 31: 27 LocalVariableTable: Start Length Slot Name Signature 0 28 0 args [Ljava/lang/String; MethodParameters: Name Flags args public org.springframework.web.client.RestTemplate restTemplate(); descriptor: ()Lorg/springframework/web/client/RestTemplate; flags: ACC_PUBLIC Code: stack=3, locals=2, args_size=1 0: new #8 // class org/springframework/http/client/SimpleClientHttpRequestFactory  3: dup 4: invokespecial #9 // Method org/springframework/http/client/SimpleClientHttpRequestFactory.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V  7: astore_1 8: aload_1 9: sipush 20000 12: invokevirtual #10 // Method org/springframework/http/client/SimpleClientHttpRequestFactory.setConnectTimeout:(I)V  15: aload_1 16: sipush 20000 19: invokevirtual #11 // Method org/springframework/http/client/SimpleClientHttpRequestFactory.setReadTimeout:(I)V  22: new #12 // class org/springframework/web/client/RestTemplate  25: dup 26: aload_1 27: invokespecial #13 // Method org/springframework/web/client/RestTemplate.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:(Lorg/springframework/http/client/ClientHttpRequestFactory;)V  30: areturn LineNumberTable: line 35: 0 line 37: 8 line 38: 15 line 39: 22 LocalVariableTable: Start Length Slot Name Signature 0 31 0 this Lcom/taifung/qrcode/chn/bocpay/BocPayBootstrap; 8 23 1 clientHttpRequestFactory Lorg/springframework/http/client/SimpleClientHttpRequestFactory; RuntimeVisibleAnnotations: 0: #35() static {}; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 0: ldc #5 // class com/taifung/qrcode/chn/bocpay/BocPayBootstrap  2: invokestatic #14 // Method org/slf4j/LoggerFactory.getLogger:(Ljava/lang/Class;)Lorg/slf4j/Logger;  5: putstatic #2 // Field log:Lorg/slf4j/Logger;  8: return LineNumberTable: line 19: 0 } SourceFile: \u0026#34;BocPayBootstrap.java\u0026#34; RuntimeVisibleAnnotations: 0: #39() 1: #40() 2: #41(#42=[s#43,s#44,s#45,s#46]) 3: #47(#48=[c#49]) 此命令将这个class文件的相关内容全部都解析出来了，其中ACC_开头的代表的是类或者接口的访问信息，如：这个类是Class还是接口；是否定义为public类型的，是否是abstract，如果是类，是否被声明final等。access_flags中一共有16个标志位可以使用。\n类索引、父类索引与接口索引集合 Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础支柱之一。\n下面此说明十分重要，这就完全说明java可以在运行中改变一些类的行为，实现语言使用者的定制化服务。\n 任何一个Class文件都对应着唯一的一个类或者接口的定义信息，但是反过来说，类或者接口并不一定都得定义在文件里（譬如类或者接口也可以动态生成，直接送入类加载器中）。\n  目录 上一章：JVM性能监控及故障处理命令 下一节：JVM性能监控及故障处理命令  ","date":"2020-12-28T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm07.%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","title":"《深入理解JVM》——07.类文件结构"},{"content":"JVM性能监控及故障处理命令 jps命令(JVM Process Status Tool) jps -l \n输出jvm当前运行的pid及的服务主类的全名，要比ps -ef | grep XXX方便\njps -v \n输出虚拟机进程启动时的JVM参数，超级好用。\njstat命令(JVM Statistics Monitoring Tool) jstat -gcutil $pid\n输出java堆各个区域已使用空间占总空间的百分比。E(Eden)、S0(Survivor0)、S1(Survivor1)、O(Old)、P(Permanent)、YGC(Young GC)、YGCT(Young GC Time,单位s)。后面见名思意，自行理解即可。\n更新中\u0026hellip;\n 目录 上一章：JVM内存分配 下一节：JVM性能监控及故障处理命令  ","date":"2020-12-24T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm06.jvm%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%8F%8A%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/","title":"《深入理解JVM》——06.JVM性能监控及故障处理命令"},{"content":"————摘自https://github.com/unknwon/the-way-to-go_ZH_CN\n2.1 平台与架构 Go 语言开发团队开发了适用于以下操作系统的编译器：\n Linux FreeBSD Mac OS X（也称为 Darwin）  目前有2个版本的编译器：Go 原生编译器 gc 和非原生编译器 gccgo，这两款编译器都是在类 Unix 系统下工作 。其中，gc 版本的编译器已经被移植到 Windows 平台上，并集成在主要发行版中，你也可以通过安装 MinGW 从而在 Windows 平台下使用 gcc 编译器。这两个编译器都是以单通道的形式工作。\n你可以获取以下平台上的 Go 1.4 源码和二进制文件：\n Linux 2.6+：amd64、386 和 arm 架构 Mac OS X（Snow Leopard + Lion）：amd64 和 386 架构 Windows 2000+：amd64 和 386 架构  对于非常底层的纯 Go 语言代码或者包而言，在各个操作系统平台上的可移植性是非常强的，只需要将源码拷贝到相应平台上进行编译即可，或者可以使用交叉编译来构建目标平台的应用程序（第 2.2 节）。但如果你打算使用 cgo 或者类似文件监控系统的软件，就需要根据实际情况进行相应地修改了。\n  Go 原生编译器 gc：\n主要基于 Ken Thompson 先前在 Plan 9 操作系统上使用的 C 工具链。\nGo 语言的编译器和链接器都是使用 C 语言编写并产生本地代码，Go 不存在自我引导之类的功能。因此如果使用一个有不同指令集的编译器来构建 Go 程序，就需要针对操作系统和处理器架构（32 位操作系统或 64 位操作系统）进行区别对待。（ 译者注：Go从1.5版本开始已经实现自举。Go语言的编译器和链接器都是Go语言编写的）\n这款编译器使用非分代、无压缩和并行的方式进行编译，它的编译速度要比 gccgo 更快，产生更好的本地代码，但编译后的程序不能够使用 gcc 进行链接。\n编译器目前支持以下基于 Intel 或 AMD 处理器架构的程序构建。\n图2.1 gc 编译器支持的处理器架构\n当你第一次看到这套命名系统的时候你会觉得很奇葩，不过这些命名都是来自于 Plan 9 项目。\n g = 编译器：将源代码编译为项目代码（程序文本）\rl = 链接器：将项目代码链接到可执行的二进制文件（机器代码）\r （相关的 C 编译器名称为 6c、8c 和 5c，相关的汇编器名称为 6a、8a 和 5a）\n标记（Flags） 是指可以通过命令行设置可选参数来影响编译器或链接器的构建过程或得到一个特殊的目标结果。\n可用的编译器标记如下：\n flags:\r-I 针对包的目录搜索\r-d 打印声明信息\r-e 不限制错误打印的个数\r-f 打印栈结构\r-h 发生错误时进入恐慌（panic）状态\r-o 指定输出文件名 // 详见第3.4节\r-S 打印产生的汇编代码\r-V 打印编译器版本 // 详见第2.3节\r-u 禁止使用 unsafe 包中的代码\r-w 打印归类后的语法解析树\r-x 打印 lex tokens\r 从 Go 1.0.3 版本开始，不再使用 8g，8l 之类的指令进行程序的构建，取而代之的是统一的 go build 和 go install 等命令，而这些指令会自动调用相关的编译器或链接器。\n如果你想获得更深层次的信息，你可以在目录 $GOROOT/src/cmd 下找到编译器和链接器的源代码。Go 语言本身是由 C 语言开发的，而不是 Go 语言（Go 1.5 开始自举）。词法分析程序是 GNU bison，语法分析程序是名为 $GOROOT/src/cmd/gc/go.y 的 yacc 文件，它会在同一目录输出 y.tab.{c,h} 文件。如果你想知道更多有关构建过程的信息，你可以在 $GOROOT/src/make.bash 中找到。\n大部分的目录都包含了名为 doc.go 的文件，这个文件提供了更多详细的信息。\n  gccgo 编译器：\n一款相对于 gc 而言更加传统的编译器，使用 GCC 作为后端。GCC 是一款非常流行的 GNU 编译器，它能够构建基于众多处理器架构的应用程序。编译速度相对 gc 较慢，但产生的本地代码运行要稍微快一点。它同时也提供一些与 C 语言之间的互操作性。\n从 Go 1 版本开始，gc 和 gccgo 在编译方面都有等价的功能。\n  文件扩展名与包（package）：\nGo 语言源文件的扩展名很显然就是 .go。\nC 文件使用后缀名 .c，汇编文件使用后缀名 .s。所有的源代码文件都是通过包（packages）来组织。包含可执行代码的包文件在被压缩后使用扩展名 .a（AR 文档）。\nGo 语言的标准库（第 9.1 节）包文件在被安装后就是使用这种格式的文件。\n注意 当你在创建目录时，文件夹名称永远不应该包含空格，而应该使用下划线 \u0026ldquo;_\u0026rdquo; 或者其它一般符号代替。\n  链接  目录 上一章：语言的主要特性与发展的环境和影响因素 下一节：Go 环境变量  ","date":"2020-12-21T00:00:00Z","permalink":"https://yunteng9345.github.io/p/go%E8%AF%AD%E8%A8%80%E5%B9%B3%E5%8F%B0%E4%B8%8E%E6%9E%B6%E6%9E%84/","title":"go语言《平台与架构》"},{"content":"Java虚拟机内存分配与回收策略 java体系的自动内存管理，最根本的目的是自动化地解决两个问题：\n 自动给对象分配内存 自动回收分配给对象的内存  在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下也可能分配在老年代。\n对象优先在Eden分配 大多数情况下 ，对象在新生代Eden区中分配。当Eden中没有足够空间进行分配时，虚拟机将发起一次Minor GC。HotSpot虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出时输出当前内存各个区域分配情况。\n大对象直接进入老年代 HotSpot虚拟机提供了-XX:PretenureSizeThreshold参数（只对Serial和ParNew两款新生代收集器有效），指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作\n长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其的年龄设置成1岁。对象在Survivor区中每熬过；一次Minor GC，年龄增加1岁，当它的年龄增加到一定程度（默认15岁），就会被晋升到老年代中。对对象的晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置\n动态对象的判定 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX:MaxTenuringThreshold要求的年龄。\n空间分配担保 在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个成立，则虚拟机会先查看-XX:HandkePromotionFailure参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。\n 目录 上一章：各类垃圾收集器分析 下一节：JVM性能监控及故障处理命令  ","date":"2020-12-21T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm05.jvm%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","title":"《深入理解JVM》——05.JVM内存分配"},{"content":"————摘自https://github.com/unknwon/the-way-to-go_ZH_CN\n1.2 语言的主要特性与发展的环境和影响因素 1.2.1 影响 Go 语言发展的早期编程语言 正如 “21 世纪的 C 语言” 这句话所说，Go 语言并不是凭空而造的，而是和 C++、Java 和 C# 一样属于 C 系。不仅如此，设计者们还汲取了其它编程语言的精粹部分融入到 Go 语言当中。\n在声明和包的设计方面，Go 语言受到 Pascal、Modula 和 Oberon 系语言的影响；在并发原理的设计上，Go 语言从同样受到 Tony Hoare 的 CSP（通信序列进程 Communicating Sequential Processes）理论影响的 Limbo 和 Newsqueak 的实践中借鉴了一些经验，并使用了和 Erlang 类似的机制。\n这是一门完全开源的编程语言，因为它使用 BSD 授权许可，所以任何人都可以进行商业软件的开发而不需要支付任何费用。\n尽管为了能够让目前主流的开发者们能够对 Go 语言中的类 C 语言的语法感到非常亲切而易于转型，但是它在极大程度上简化了这些语法，使得它们比 C/C++ 的语法更加简洁和干净。同时，Go 语言也拥有一些动态语言的特性，这使得使用 Python 和 Ruby 的开发者们在使用 Go 语言的时候感觉非常容易上手。\n下图展示了一些其它编程语言对 Go 语言的影响：\n图 1.3 其它编程语言对 Go 语言的影响\n1.2.2 为什么要创造一门编程语言  C/C++ 的发展速度无法跟上计算机发展的脚步，十多年来也没有出现一门与时代相符的主流系统编程语言，因此人们需要一门新的系统编程语言来弥补这个空缺，尤其是在计算机信息时代。 相比计算机性能的提升，软件开发领域不被认为发展得足够快或者比硬件发展得更加成功（有许多项目均以失败告终），同时应用程序的体积始终在不断地扩大，这就迫切地需要一门具备更高层次概念的低级语言来突破现状。 在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。  1.2.3 Go 语言的发展目标 Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。\n因此，Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。\nGo 语言的另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机，这一点对于谷歌内部的使用来说就非常重要了。设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化。\n这个特性显然是 Go 语言最强有力的部分，不仅支持了日益重要的多核与多处理器计算机，也弥补了现存编程语言在这方面所存在的不足。\nGo 语言中另一个非常重要的特性就是它的构建速度（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。作为大量使用 C++ 来构建基础设施的谷歌来说，无疑从根本上摆脱了 C++ 在构建速度上非常不理想的噩梦。这不仅极大地提升了开发者的生产力，同时也使得软件开发过程中的代码测试环节更加紧凑，而不必浪费大量的时间在等待程序的构建上。\n依赖管理是现今软件开发的一个重要组成部分，但是 C 语言中“头文件”的概念却导致越来越多因为依赖关系而使得构建一个大型的项目需要长达几个小时的时间。人们越来越需要一门具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。\n整个 Go 语言标准库的编译时间一般都在 20 秒以内，其它的常规项目也只需要半秒钟的时间来完成编译工作。这种闪电般的编译速度甚至比编译 C 语言或者 Fortran 更加快，使得编译这一环节不再成为在软件开发中困扰开发人员的问题。在这之前，动态语言将快速编译作为自身的一大亮点，像 C++ 那样的静态语言一般都有非常漫长的编译和链接工作。而同样作为静态语言的 Go 语言，通过自身优良的构建机制，成功地去除了这个弊端，使得程序的构建过程变得微不足道，拥有了像脚本语言和动态语言那样的高效开发的能力。\n另外，Go 语言在执行速度方面也可以与 C/C++ 相提并论。\n由于内存问题（通常称为内存泄漏）长期以来一直伴随着 C++ 的开发者们，Go 语言的设计者们认为内存管理不应该是开发人员所需要考虑的问题。因此尽管 Go 语言像其它静态语言一样执行本地代码，但它依旧运行在某种意义上的虚拟机，以此来实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。\n尽管垃圾回收并不容易实现，但考虑这将是未来并发应用程序发展的一个重要组成部分，Go 语言的设计者们还是完成了这项艰难的任务。\nGo 语言还能够在运行时进行反射相关的操作。\n使用 go install 能够很轻松地对第三方包进行部署。\n此外，Go 语言还支持调用由 C 语言编写的海量库文件（第 3.9 节），从而能够将过去开发的软件进行快速迁移。\n1.2.4 指导设计原则 Go语言通过减少关键字的数量（25 个）来简化编码过程中的混乱和复杂度。干净、整齐和简洁的语法也能够提高程序的编译速度，因为这些关键字在编译过程中少到甚至不需要符号表来协助解析。\n这些方面的工作都是为了减少编码的工作量，甚至可以与 Java 的简化程度相比较。\nGo 语言有一种极简抽象艺术家的感觉，因为它只提供了一到两种方法来解决某个问题，这使得开发者们的代码都非常容易阅读和理解。众所周知，代码的可读性是软件工程里最重要的一部分（ 译者注：代码是写给人看的，不是写给机器看的 ）。\n这些设计理念没有建立其它概念之上，所以并不会因为牵扯到一些概念而将某个概念复杂化，他们之间是相互独立的。\nGo 语言有一套完整的编码规范，你可以在 Go 语言编码规范 页面进行查看。\n它不像 Ruby 那样通过实现过程来定义编码规范。作为一门具有明确编码规范的语言，它要求可以采用不同的编译器如 gc 和 gccgo（第 2.1 节）进行编译工作，这对语言本身拥有更好的编码规范起到很大帮助。\nLALR 是 Go 语言的语法标准，你也可以在 src/cmd/internal/gc/go.y 中查看到，这种语法标准在编译时不需要符号表来协助解析。\n1.2.5 语言的特性 Go 语言从本质上（程序和结构方面）来实现并发编程。\n因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。\n在传统的面向对象语言中，使用面向对象编程技术显得非常臃肿，它们总是通过复杂的模式来构建庞大的类型层级，这违背了编程语言应该提升生产力的宗旨。\n函数是 Go 语言中的基本构件，它们的使用方法非常灵活。在第六章，我们会看到 Go 语言在函数式编程方面的基本概念。\nGo 语言使用静态类型，所以它是类型安全的一门语言，加上通过构建到本地代码，程序的执行速度也非常快。\n作为强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。\nGo 语言其实也有一些动态语言的特性（通过关键字 var），所以它对那些逃离 Java 和 .Net 世界而使用 Python、Ruby、PHP 和 JavaScript 的开发者们也具有很大的吸引力。\nGo 语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go 语言做到了真正的国际化！\n1.2.6 语言的用途 Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。\nGo 语言一个非常好的目标就是实现所谓的复杂事件处理（CEP），这项技术要求海量并行支持，高度的抽象化和高性能。当我们进入到物联网时代，CEP 必然会成为人们关注的焦点。\n但是 Go 语言同时也是一门可以用于实现一般目标的语言，例如对于文本的处理，前端展现，甚至像使用脚本一样使用它。\n值得注意的是，因为垃圾回收和自动内存分配的原因，Go 语言不适合用来开发对实时性要求很高的软件。\n越来越多的谷歌内部的大型分布式应用程序都开始使用 Go 语言来开发，例如谷歌地球的一部分代码就是由 Go 语言完成的。\n如果你想知道一些其它组织使用Go语言开发的实际应用项目，你可以到 使用 Go 的组织 页面进行查看。出于隐私保护的考虑，许多公司的项目都没有展示在这个页面。我们将会在第 21 章讨论到一个使用 Go 语言开发的大型存储区域网络（SAN）案例。\n在 Chrome 浏览器中内置了一款 Go 语言的编译器用于本地客户端（NaCl），这很可能会被用于在 Chrome OS 中执行 Go 语言开发的应用程序。\nGo 语言可以在 Intel 或 ARM 处理器上运行，因此它也可以在安卓系统下运行，例如 Nexus 系列的产品。\n在 Google App Engine 中使用 Go 语言：2011 年 5 月 5 日，官方发布了用于开发运行在 Google App Engine 上的 Web 应用的 Go SDK，在此之前，开发者们只能选择使用 Python 或者 Java。这主要是 David Symonds 和 Nigel Tao 努力的成果。目前最新的稳定版是基于 Go 1.4 的 SDK 1.9.18，于 2015 年 2 月 18 日发布。当前 Go 语言的稳定版本是 Go 1.4.2。\n1.2.7 关于特性缺失 许多能够在大多数面向对象语言中使用的特性 Go 语言都没有支持，但其中的一部分可能会在未来被支持。\n 为了简化设计，不支持函数重载和操作符重载 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换 Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型 不支持动态加载代码 不支持动态链接库 不支持泛型 通过 recover 和 panic 来替代异常机制（第 13.2-3 节） 不支持静态变量  关于 Go 语言开发团队对于这些方面的讨论，你可以通过 Go 常见问题 页面查看。\n1.2.8 使用 Go 语言编程 如果你有其它语言的编程经历（面向对象编程语言，如：Java、C#、Object-C、Python、Ruby），在你进入到 Go 语言的世界之后，你将会像迷恋你的 X 语言一样无法自拔。Go 语言使用了与其它语言不同的设计模式，所以当你尝试将你的X语言的代码迁移到 Go 语言时，你将会非常失望，所以你需要从头开始，用 Go 的理念来思考。\n如果你在至高点使用 Go 的理念来重新审视和分析一个问题，你通常会找到一个适用于 Go 语言的优雅的解决方案。\n1.2.9 小结 这里列举一些 Go 语言的必杀技：\n 简化问题，易于学习 内存管理，简洁语法，易于使用 快速编译，高效开发 高效执行 并发支持，轻松驾驭 静态类型 标准类库，规范统一 易于部署 文档全面 免费开源  链接  目录 上一节：起源与发展 下一章：安装与运行环境  ","date":"2020-12-14T00:00:00Z","permalink":"https://yunteng9345.github.io/p/go%E8%AF%AD%E8%A8%80%E8%AF%AD%E8%A8%80%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%E4%B8%8E%E5%8F%91%E5%B1%95%E7%9A%84%E7%8E%AF%E5%A2%83%E5%92%8C%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0/","title":"go语言《语言的主要特性与发展的环境和影响因素》"},{"content":"————摘自https://github.com/unknwon/the-way-to-go_ZH_CN\n1.1 起源与发展 Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20% 兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想。\n这是一个由计算机领域 “发明之父” 所组成的黄金团队，他们对系统编程语言，操作系统和并行都有着非常深刻的见解\n图 1.1 Go 语言设计者：Griesemer、Thompson 和 Pike\n在 2008 年年中，Go 语言的设计工作接近尾声，一些员工开始以全职工作状态投入到这个项目的编译器和运行实现上。Ian Lance Taylor 也加入到了开发团队中，并于 2008 年 5 月创建了一个 gcc 前端。\nRuss Cox 加入开发团队后着手语言和类库方面的开发，也就是 Go 语言的标准包。在 2009 年 10 月 30 日，Rob Pike 以 Google Techtalk 的形式第一次向人们宣告了 Go 语言的存在。\n直到 2009 年 11 月 10 日，开发团队将 Go 语言项目以 BSD-style 授权（完全开源）正式公布了 Linux 和 Mac OS X 平台上的版本。Hector Chu 于同年 11 月 22 日公布了 Windows 版本。\n作为一个开源项目，Go 语言借助开源社区的有生力量达到快速地发展，并吸引更多的开发者来使用并改善它。自该开源项目发布以来，超过 200 名非谷歌员工的贡献者对 Go 语言核心部分提交了超过 1000 个修改建议。在过去的 18 个月里，又有 150 开发者贡献了新的核心代码。这俨然形成了世界上最大的开源团队，并使该项目跻身 Ohloh 前 2% 的行列。大约在 2011 年 4 月 10 日，谷歌开始抽调员工进入全职开发 Go 语言项目。开源化的语言显然能够让更多的开发者参与其中并加速它的发展速度。Andrew Gerrand 在 2010 年加入到开发团队中成为共同开发者与支持者。\n在 Go 语言在 2010 年 1 月 8 日被 Tiobe（闻名于它的编程语言流行程度排名）宣布为 “2009 年年度语言” 后，引起各界很大的反响。目前 Go 语言在这项排名中的最高记录是在 2017 年 1 月创下的第13名，流行程度 2.325%。\n时间轴：  2007 年 9 月 21 日：雏形设计 2009 年 11 月 10日：首次公开发布 2010 年 1 月 8 日：当选 2009 年年度语言 2010 年 5 月：谷歌投入使用 2011 年 5 月 5 日：Google App Engine 支持 Go 语言  从 2010 年 5 月起，谷歌开始将 Go 语言投入到后端基础设施的实际开发中，例如开发用于管理后端复杂环境的项目。有句话叫 “吃你自己的狗食”，这也体现了谷歌确实想要投资这门语言，并认为它是有生产价值的。\nGo 语言的官方网站是 golang.org，这个站点采用 Python 作为前端，并且使用 Go 语言自带的工具 godoc 运行在 Google App Engine 上来作为 Web 服务器提供文本内容。在官网的首页有一个功能叫做 Go Playground，是一个 Go 代码的简单编辑器的沙盒，它可以在没有安装 Go 语言的情况下在你的浏览器中编译并运行 Go，它提供了一些示例，其中包括国际惯例 “Hello, World!”。\n更多的信息详见 github.com/golang/go，Go 项目 Bug 追踪和功能预期详见 github.com/golang/go/issues。\nGo 通过以下的 Logo 来展示它的速度，并以囊地鼠（Gopher）作为它的吉祥物。\n图1.2 Go 语言 Logo\n谷歌邮件列表 golang-nuts 非常活跃，每天的讨论和问题解答数以百计。\n关于 Go 语言在 Google App Engine 的应用，这里有一个单独的邮件列表 google-appengine-go，不过 2 个邮件列表的讨论内容并不是分得很清楚，都会涉及到相关的话题。go-lang.cat-v.org/ 是 Go 语言开发社区的资源站，irc.freenode.net 的#go-nuts 是官方的 Go IRC 频道。\n@golang 是 Go 语言在 Twitter 的官方帐号，大家一般使用 #golang 作为话题标签。\n这里还有一个在 Linked-in 的小组：www.linkedin.com/groups?gid=2524765\u0026amp;trk=myg_ugrp_ovr。\nGo 编程语言的维基百科：en.wikipedia.org/wiki/Go_(programming_language)\nGo 语言相关资源的搜索引擎页面：gowalker.org\nGo 语言还有一个运行在 Google App Engine 上的 Go Tour，你也可以通过执行命令 go install go-tour.googlecode.com/hg/gotour 安装到你的本地机器上。对于中文读者，可以访问该指南的 中文版本，或通过命令 go install https://bitbucket.org/mikespook/go-tour-zh/gotour 进行安装。\n链接  目录 下一章：安装与运行环境  ","date":"2020-12-14T00:00:00Z","permalink":"https://yunteng9345.github.io/p/go%E8%AF%AD%E8%A8%80%E8%B5%B7%E6%BA%90%E4%B8%8E%E5%8F%91%E5%B1%95/","title":"go语言《起源与发展》"},{"content":"经典垃圾收集器 如果两个收集器之间存在连线，就说明他们可搭配使用。直到目前为止，也没有万能的收集器，只能是在合适的场景下选择合适的收集器。\nSerial收集器 Serial收集器，从名字就可以看出是单线程工作的收集器，但更重要的是强调他在进行垃圾收集时，必须暂停其他所有的工作。“Stop The World”的理解用一个故事就可以说明：你妈在打扫房间的时候，是不是让你在椅子上或者房间外面待着，如果她一遍打扫，你一边扔纸屑，这个房间永远都打扫不干净了。\n迄今为止，它依然是HotSpot虚拟机运行在客户端模式下（用户桌面）的默认新生代收集器，与其他单线程收集器比较起来十分简单高效，对于内存资源受限的环境，它是所有收集器里额外内存消（Memory Footprint）最小的。因为它不需要和其他线程进行交互，专心只做一件事情。所以说：Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。\nParNew收集器 ParNew收集器实质上Serial收集器的多线程并行版本，除了使用多线程进行垃圾收集之外，其余行为和控制参数和Serial收集器完全一致。但目前为止只有它能与CMS收集器配合工作。\nCMS收集器，这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，**它首次实现了让垃圾收集线程和用户线程（基本上）同时工作。**在JDK5中使用CMS来收集老年代的时候，新生代只能选择Serial收集器和ParNew收集器，而ParNew收集器是激活CMS后（使用-XX:+UseConcMarkSweepGC选项）的默认新生代收集器，也可以使用-XX:+/-UseParNewGC选项来强制指定和禁用。\n虽然ParNew十分强大，但随着技术的升级。现在已经被十分NB的G1收集器所取代。G1收集器是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。正所谓：长江后浪推前浪，一代更比一代强，欲知后事如何，请继续看以下讲解的收集器。\nParallel Scavenge收集器 Parallel Scavenge也是一款新生代收集器，它同样是标记-复制算法实现的收集器，也是能够并行收集的多线程收集器，与ParNew非常相似。\nParallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量（Throughput）。\n 吞吐量= {运行用户代码时间} / (运行用户代码时间 + 运行垃圾收集时间)\n Parallel Scavenge收集器提供了俩个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。\n -XX:MaxGCPauseMillis这个值并不是设置的越小越好，因为垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的！\n Serial Old收集器 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法，新生代采用复制算法暂停所有用户线程，老年代采用标记-整理算法暂停所有用户线程。这个收集器的主要意义也是提供客户端模式下的HotSpot虚拟机使用。 使用场景如下：\n 在JDK5以及之前的版本中与Parallel收集器搭配使用 作为CMS收集器发生失败时的后背预案，在并发收集Concurrent Mode Failure时使用  Parallel Old收集器 是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。\nCMS收集器(jdk8中重点使用的收集器，我司正在使用) CMS(Concurrent Mark Sweep)收集器是一种以获取最短停顿时间为目标的收集器。因为目前大部分java应用都是基于浏览器的B/S系统的服务端，这类服务较为关注服务的响应速度，希望系统停顿时间尽可能短，已给用户带来友好的体验。\n从名字看以看出它是基于标记-清除算法实现的。整个过程分为以下四部分：\n 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep）   其中初始标记、重新标记这两个步骤仍然需要“stop the world”。\n 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；\n并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时很长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行；\n重新标记则是为了修正并发标记期间，因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短；\n并发清除，清理删除标记阶段的判断已经死亡的对象，由于不需要移动存活的对象，所以这个阶段是可以与用户线程同时并发的。\n为说明，特将书中的收集器运行图画出便于理解。\n虽然设计的如此强大，但还是有很多缺点，此时此刻我不禁想吟诗一首\u0026hellip;\n 明月几时有？把酒问青天。不知天上宫阙，今夕是何年。我欲乘风归去，又恐琼楼玉宇，高处不胜寒。起舞弄清影，何似在人间！转朱阁，低绮户，照无眠。不应有恨，何事偏向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。 ——苏轼《水调歌头 明月几时有》  在并发阶段，虽然不会导致用户线程停顿，但却会因为占用了一部分线程（处理器的计算能力）而导致程序变慢，降低吞吐量。\n由于CMS是一种基于“标记-清除”的算法实现的，所以在垃圾收集完成之后会产生大量的空间碎片，空间碎片太多时，会影响对大对象的内存分配，而不得已提前触发一次Full GC。为了解决这个问题，CMS提供了一个-XX:+UseCMS-CompactAtFullCollection开关参数，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程。\nGarbage First 收集器(G1) Garbage First(简称G1)收集器是垃圾收集器技术发展历史上的里程碑式的成果。它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式，JDK 8 Update 40之后，G1提供并发的类卸载的支持，这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”（Full-Featured Garbage Collector）\nG1是一款主要面向服务端应用的垃圾收集器。JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。\n作为CMS收集器的代替者和继承人，设计者们希望做出一款能够建立起“停顿时间模型”的收集器，停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标，这几乎已经是实时Java的中软实时垃圾收集的特征了。\n在G1收集器出现之前的所有其他的收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），在要么就是整个Java堆（Full GC）。而G1跳出了这个牢笼，它可以面向堆内存任何部分来组成回收集（Collection Set,简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾最多，回收收益最大，这就是G1的Mixed GC模式。\nG1开创的基于Region的堆内存布局是它能够实现这个目标的关键。虽然G1也是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异；G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器可以扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。\nG1收集器之所以能够建立可预测的可停顿的时间模型，是因为它将Region作为单次回收的最小单元。即每次收集到的内存都是Region空间的整数倍。在收集过程中，Region会记录很多相关信息。G1收集的过程总结如下：\n 初始化标记（Initial Marking）：仅仅就是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。 并发标记（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，递归描述整个堆里的对象图，要出要回收的对象，这个阶段耗时比较长，但可以与用户陈序并发执行。 最终标记（Final Marking）：对用户线程做一个短暂的暂停，用户处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。 筛选回收（Live Data Counting and Exacuation）：负责更新Region的统计数据就，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收的计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，在清理掉这个旧Region的全部空间。 这里的操作涉及存活对象的移动，必须暂停用户线程。  总结 垃圾收集器可以一直升级迭代，但是思想是永恒不变的。所以我认为对于技术学习而言，一定要触类旁通。只要这样才能形成适合自己的知识体系。\n 目录 上一章：各类垃圾收集器分析 下一节：JVM内存分配  ","date":"2020-12-10T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm04.%E5%90%84%E7%B1%BB%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E6%9E%90/","title":"《深入理解JVM》——04.各类垃圾收集器分析"},{"content":"垃圾收集器算法 因为程序计数器、虚拟机栈、本地方法栈都是随线程而生，随线程而灭。所以主要的垃圾收集区域集中在堆区域和方法区，堆里面存放着Java世界中几乎所有对象的实例，垃圾收集器在对堆进行回收之前，第一件事情就是要确认这些对象之中还有哪些“存活”，哪些已经“死去”。\n引用计数算法(Reference Counting) 对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用实效时，计数器值减一；任何时刻计数器为零的对象就是不可能再被使用的。但在Java主流的虚拟机里都没有使用引用计数算法来实现垃圾回收，因为它很难解决对象之间相互循环引用的问题。\n可达性分析算法(Reachability Analysis) 这个算法的基本思路就是通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走的路径称为“引用链”(Reference Cain)，如果某个对象到GC Root键没有任何引用链相连，或者用图论的话来说就是从GC Root到这个对象不可达时，则证明此对象是不可能再被使用的。\n在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：\n 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。 在本地方法栈中JNI引用的对象 Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（如NPE、OOE）等，还有系统类加载器。 所有被同步锁（synchronized）所持有的对象 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。  回收方法区 Java堆中，新生代对常规应用进行一次垃圾回收通常可以回收70%至99%的内存空间。\n方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。\n 举个例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他的地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断有必要的话，这个“java”常量就将会被系统清理出常量池。常量池中其他类（接口）、方法、字段的符号引用也类似。\n 判断一个类型是否属于“不在被使用的类”需要同时满足以下三个条件：\n 该类所有的实例都已经被回收 加载该类的类加载器已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  垃圾收集算法 分代收集理论 所谓分代收集理论，实质上一套符合大多数程序运行实际情况的经验法则，它建立在俩个分代假说之上\n 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集的对象就越难以消灭。  收集器应该将Java堆分成不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储\n如果一个区域中大多数对象都是朝生夕灭，我们可以把它们集中在一起，每次回收时只关注如何保留少量存活的对象，而不是去标记那些大量将要被回收的对象，这样就能以较低的代价回收到大量的空间；\n如果剩下的都是难以消亡的对象，那把它们集中到一起，虚拟机可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存空间的有效利用。\n标记-清除算法（Mark- Sweep） 首先标记出所有需要回收的对象，在标记完成之后，统一回收所有被标记的对象，或者所有未被标记的对象。\n 缺点1：效率不稳定，随堆中对象的数量线性增长。\n  缺点2：标记-清除后产生大量不连续的内存碎片，分配大对象时无法找到连续的内存不得不提前触发垃圾回收操作。\n 标记-复制算法 它将可用内存按容量分为大小相等的两块，没次只使用其中的一块。当这一块的内存用完了，就将存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销。\n 缺点：可用内存缩小为原来的一半。\n 标记复制算法的进化-Appel式回收 标记-整理算法（Mark Compact） 标记-整理算法，其中的标记过程任然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一段移动，然后直接清理掉边界以外的的内存。\n如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存货区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行（Stop The World）\n移动对象会使内存回收时更加复杂，不移动会使内存分配时更加复杂。从垃圾回收的角度来说，不移动对象停顿的时间短，甚至不停顿，但是从整个程序的吞吐量来看，移动对象更加划算。所以HotSpot虚拟机中关注吞吐的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器是基于标记-清除算法的。\n所以便衍生出了折中的方案，平时多数使用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，在采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的CMS收集器面临空间碎片过多时就是采用这种方法。\n 出现STW的现象完全是因为内存空间碎片影响了正常的内存分配，所以需要停顿各个线程整理内存空间。\n HotSpot算法实现细节 准确式垃圾收集。在HotSpot的解决方案里，**是使用一组OopMap的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。**这样收集器在扫描时就可以直接得知这些信息了，并不需要一个不漏的从GC Roots开始查找。\n安全点-安全区域 用户线程在执行过程中可以中断的点和区域，进去此点和此区域即可进行垃圾收集。\n 准确式垃圾收集目标：使用记忆集来缩短GC Roots扫描范围。\n 并发可达性分析 可达性分析算法理论上要求全过程都能保障一致性的快照才能分析，这意味着必须全程冻结用户线程的运行。并发情况下，用户线程同时修改引用关系，会产生将已经消亡的对象标记为存活状态，也可能会产生把原本存活的对象标记为已消亡。要解决并发扫描时的对象消失问题，出现了两种解决方案：增量更新和原始快照。这两种的目的都是将冲突的扫描暂存起来，然后重新扫描。\n例如CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现的。\n 目录 上一章：创建对象过程 下一节：各类垃圾收集器分析  ","date":"2020-11-26T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm03.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%90%86%E8%AE%BA/","title":"《深入理解JVM》——03.垃圾收集器理论"},{"content":"Java虚拟机创建对象的过程   jvm遇到第一个new关键字\n  检查指令的参数是否能在常量池中定位到一个类的符号引用\n  检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，执行相应的类加载过程。\n  类加载检查通过后，为新生对象分配内存\n 为对象分配空间的任务实际上等同于把一块确定大小的内存从Java堆中划分出来。\n   内存分配完成之后，虚拟机将分配到的内存空间都初始化为零值\n  jvm对对象进行必要的设置，如：对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄信息。（这些信息都存在对象头之中，Object Header)\n  从虚拟机的视角来看，一个新的对象已经产生。但从java程序的视角来看，对象创建才刚刚开始。\n  一般来说（由字节码流中new指令后面是否跟随invokespecial指令所决定，java编译器会在遇到new关键字的地方同时生成这俩条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行init()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。\n  对象的内存布局  Header（对象头） Instance Data （实例数据） Padding （对齐填充）  Header 第一类用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳。信息长度一般在32比特和64比特（针对不同位数虚拟机），官方承它为“Mark Word”。第二类类型指针，即对象指向它的元数据的指针，Java虚拟机通过这个指针来确定该对象是那个类的实例。\nInstance Data 对象真正存储的有效信息，程序代码里的定义的各种类型的字段内容，父类和子类的字段都会记录。这部分的存储顺序受到虚拟机分配策略参数（-XX:FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响\nPadding 没有特殊含义，仅仅起着占位符的作用\n对象的访问定位  句柄访问，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和对象类型数据各自具体的地址信息。 直接指针，reference中存储的直接就是对象地址信息。   目录 上一章：基本概念 下一节：垃圾收集器理论  ","date":"2020-11-18T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm02.%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B/","title":"《深入理解JVM》——02.创建对象过程"},{"content":"Java基础  目录 下一章：创建对象过程  ","date":"2020-11-17T00:00:00Z","permalink":"https://yunteng9345.github.io/p/java%E5%9F%BA%E7%A1%8001.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"《Java基础》——01.基本概念"},{"content":"Java虚拟机基本概念 JVM运行时数据区域 说明 每开启一个线程JVM都给线程分配三个独立的内存区域，分别是Stack Area（虚拟机栈）、PC Registers（程序计数器）、Native Method Area（本地方法区）。而他们的共享内存区域是Method Area（方法区）、Heap（堆）。\nPC Register 程序寄存器，线程执行的字节码的行号指示器，通过改变计数器的值选取下一条执行的字节码指令，控制分支、循环、跳转、异常处理、线程恢复。\n java虚拟机的多线程是通过线程轮换、分配处理器的执行时间的方式来实现的。在任何一个确定的时刻，一个处理器（多核来说也是一个处理器）都只会执行一条线程中的指令。为了每个线程都能恢复到正确的执行位置，所以就有了PC Register。\n Stack Area 虚拟机栈，线程私有，生命周期与线程相同。每个方法被执行的时候，jvm都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息，每个方法被调用直至完成，就对应一个栈帧从入栈到出栈的过程。更多情况下只是指虚拟机栈中的局部变量表部分。局部变量表存放了编译期可知的各种Java虚拟机 基本数据类型（boolean、byte、char、short、int、float、long、double)、对象引用（reference类型，它并不等同于对象本身）\nNative Method Area 本地方法栈，与虚拟机发挥的作用非常相似，区别：VM Stacks执行Java方法，Native Method Stacks执行本地方法，如：c、cpp等。\n 有的虚拟机直接把本地方法栈和虚拟机栈合二为一使用，如Hot-Spot虚拟机\n 栈溢出的场景（StackOverflowError）代码\npublic class TestDemo { private int index = 1; public void method() { index++; method(); } @Test public void testStackOverflowError() { try { method(); } catch (StackOverflowError e) { System.out.println(\u0026#34;程序所需要的栈大小 \u0026gt; 允许最大的栈大小，执行深度: \u0026#34; + index); e.printStackTrace(); } } } java.lang.StackOverflowError at com.collection.map.MapDemo.method(MapDemo.java:29) at com.collection.map.MapDemo.method(MapDemo.java:29) at com.collection.map.MapDemo.method(MapDemo.java:29) at com.collection.map.MapDemo.method(MapDemo.java:29) at com.collection.map.MapDemo.method(MapDemo.java:29) 当栈内存超过系统配置的栈内存-Xss:2048（为jvm启动的每个线程分配的内存大小），就会出现java.lang.StackOverflowError异常。这也是为什么对于需要谨慎使用递归调用的原因！\n堆栈溢出的场景（OutOfMemoryError）代码\npublic class Heap { public static void main(String[] args) { ArrayList list = new ArrayList(); while (true) { list.add(new Heap()); } } } Exception in thread \u0026#34;main\u0026#34; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) List是动态增长的，因此容量不够了，就会扩容，一旦空闲内存分配完毕，请求不到其他内存，就抛出OutOfMemoryError。\nHeap 堆，是虚拟机管理内存中最大的一块，被所有线程共享，在虚拟机启动时创建。此内存的唯一目的是存放对象。Java堆是垃圾收集器管理的内存区域（GC堆），JVM大多数的堆容量都是可以扩展的（-Xmx和-Xms）\nMethod Area 方法区，和Java堆一样，是各个线程共享的内存区域，他用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\nRuntime Constant Pool 运行时常量池，是Method Area的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（ Constant Pool Table），用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\n 目录 下一章：创建对象过程  ","date":"2020-11-17T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3jvm01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"《深入理解JVM》——01.基本概念"},{"content":"1.下载gin时遇到网络问题. 解决办法 go env -w GOPROXY=https://goproxy.cn\n开发这个代理的老哥真的nb，可以看看他的博客和github。大佬。。https://aofeisheng.com/\n","date":"2020-11-11T00:00:00Z","permalink":"https://yunteng9345.github.io/p/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"go语言学习笔记"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n 图片  Photo by Florian Klauer on Unsplash   Photo by Luca Bravo on Unsplash \n Photo by Helena Hertz on Unsplash   Photo by Hudai Gayiran on Unsplash \n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) ","date":"2020-09-09T00:00:00Z","image":"https://yunteng9345.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://yunteng9345.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike[^1] Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n","date":"2019-03-11T00:00:00Z","image":"https://yunteng9345.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://yunteng9345.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"YouTube Privacy Enhanced Shortcode ","date":"2019-03-10T00:00:00Z","permalink":"https://yunteng9345.github.io/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt Mane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://yunteng9345.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://yunteng9345.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\n","date":"2019-03-08T00:00:00Z","permalink":"https://yunteng9345.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":" N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://yunteng9345.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://yunteng9345.github.io/p/emoji-support/","title":"Emoji Support"}]