[{"content":"金字塔原理  第1篇 表达的逻辑 第2篇 思考的逻辑 第3篇 解决问题的逻辑 第4篇 演示的逻辑  对受众（包括读者、听众、观众或学员）来说，最容易理解的顺序是：先了解主要的、抽象的思想，然后了解次要的、为主要思想提供支持的思想。\n","date":"2022-11-04T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/","title":"《金字塔原理》读书笔记"},{"content":"MySQL服务器处理客户端请求 客户端进程向服务端进程发送一段文本（MySQL语句），服务器处理后再向客户端发送一段文本（数据结果）\nmysql服务端处理流程\n 连接管理  处理连接   解析与优化  查询缓存 语法解析 查询优化   存储引擎  MyISAM、InnoDB 文件系统    InnoDB记录存储结构 InnoDB将数据划分为若干个页，以页（1页16KB）作为磁盘和内存之间交互的基本单位。\n","date":"2021-10-23T00:00:00Z","permalink":"https://yunteng9345.github.io/p/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E7%AC%94%E8%AE%B0/","title":"《MySQL是怎样运行的》笔记"},{"content":"优秀单元测试特性  他应该是自动化的，可重复执行 他应该很容易实现 他应该第二天还有意义 任何人都应该一键运行他 他应该运行速度很快 他的结果应该是很稳定的（如果运行之间没有修改，多次运行一个测试应该返回相同的结果） 他应该能完全控制被测试的单元 他应该是完全隔离的（独立于其他测试的运行） 如果他失败了，我们应该很容易发现什么是期待结果，进而定位问题  单元测试不等于集成测试 任何测试，如果他运行不快，结果不稳定，或者用到被测试单元的一个或多个真实依赖物，我们就认为他是集成测试。\n单元测试也可以共用方法，使代码一目了然\n存根（stub）和模拟对象的区别 存根是用来模拟各种场景的测试对象\n细节 测试过程中，如果一个断言失败了，那么不需要关心后面的断言\n单元测试，只做一件事情\nMock Mocks are used as a replacement for a dependency.、\n断言注意 单元测试中不应该有多个断言，如果有的话，可分成2个单元测试。避免多个关注点\n覆盖率低于20%说明缺少很多测试\n断言中的魔法值应该用常量的英文单词，可一眼看出预期。\n断言和操作分离\n单元测试失败的原因：要改变人的习惯，更多的是做出心理上的改变，而非技术上的。人们不喜欢改变，改变通常伴随着害怕、不确定和怀疑。\n image-20211111152032834 \n​\t——摘自《单元测试的艺术》\n研究表明：大部分的缺陷并不是来自代码自身，而是由人们之间的误解、不断变化的需求以及缺少应用领域知识造成的。\n","date":"2021-10-23T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/","title":"《单元测试的艺术》笔记"},{"content":"第1章——重构，第一个示例 思想  需求的变化使重构变得必要\n重构就是以微小的步伐修改程序，如果有问题，可立马发现\n傻瓜都能写出计算机可以理解的代码，唯有能写出人类容易理解的代码，才是优秀的程序员\n 步骤  重构前，检查自己是否有一套可靠的测试集，这些测试必须有自我检验的能力（单元测试） 把复杂的代码分解为更小的单元  细节  将函数分割为单一功能，提炼到外部提供调用 改动完成之后，立马编译执行一遍单元测试，原因：在真的犯了错误时：只需要考虑一个很小的改动范围，使得排查与修复问题易如反掌。 变量改名，使它们更加简洁 处理结果变量时，将循环代码和变量放在一起，然后用查询函数取代临时变量 利用多态取代条件表达式  第2章——重构的原则 思想  重构的唯一目的就是让我们开发的更快，用更少的工作量创造更大的价值。\n 第2章——重构的原则\n第3章——代码的坏味道 思想  命名函数或变量，如果想不出一个好名字，说明背后很可能潜藏着更深的设计问题。\n 步骤  规范注释，参照Spring源码   细节     ","date":"2021-10-23T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/","title":"《重构第二版》笔记"},{"content":" 从古至今，长江和黄河流域水患不断，远古时期，大禹曾拓宽河道，清除淤沙让流水更加顺畅；都江堰作为史上最成功的的治水案例之一，用引流将岷江之水分流到多个支流中，以分担水流压力；三门峡和葛洲坝通过建造水库将水引入水库先存储起来，然后再想办法把水库中的水缓缓地排出去，以此提高下游的抗洪能力。\n 高并发的处理方式目前有三种方式\n Scale-out(横向扩展)：采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。 缓存：使用缓存来提高系统的性能（空间换时间） 异步：某些场景下，处理未完成的请求时，可以先让请求返回，数据准备好之后返回请求方。这样可以在单位时间内处理更多的请求。  OSI 网络模型分层：物理层、数据链路层、 网络层、传输层、 会话层、表现层、应用层。\nTCP/IP 协议分层： 链路层、 网络层、传输层、 应用层。\n高可用系统设计的思路   系统设计\n  failover机制\n  超时调整\n  降级、限流\n    系统运维\n  灰度发布\n  故障演练\n    高可扩展性的设计思路  拆分，将复杂问题简单化   1. 存储层的扩展性  业务维度 数据库维度  2. 业务层的扩展性  业务 重要性 请求来源  对于数据库连接池，根据我的经验，一般在线上我建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。\njava线程池学习（重要）\n在 4 核 8G 的机器上运 MySQL 5.7 时，大概可以支撑 500 的 TPS 和 10000 的 QPS\nMysql主从复制\n img \n主从同步过程：从库在连接到主节点时，会创建一个IO线程，用来请求主库的binlog。把接收到的binlog信息写入relay log的日志文件中。而主库也会创建一个log dump的线程来发送binlog给从库。同事，从库还会创建一个SQL线程读取relay log中的内容，然后做回放将信息写入从库。\n同步延迟导致短时间数据不一致问题处理方案\n 数据冗余（推荐使用，效率高） 使用缓存 查询主库  倒排索引 倒排索引是指将记录中的某些列做分词，然后形成的分词与记录 ID 之间的映射关系。比如说，你的垂直电商项目里面有以下记录：\n img \n那么，我们将商品名称做简单的分词，然后建立起分词和商品 ID 的对应关系，就像下面展示的这样：\n img \n分布式缓存的高可用的3种主流方案   客户端方案，一般也称为 Smart Client。我们通过制定一些数据分片和数据读写的策略，可以实现缓存高可用。这种方案的好处是性能没有损耗，缺点是客户端逻辑复杂且在多语言环境下不能复用。\n  中间代理方案，在客户端和缓存节点之间增加了中间层，在性能上会有一些损耗，在代理层会有一些内置的高可用方案，比如 Codis 会使用 Codis Ha 或者 Sentinel。\n  服务端方案，依赖于组件的实现，Memcached 就只支持单机版没有分布式和 HA 的方案，而 Redis 在 2.4 版本提供了 Sentinel 方案可以自动进行主从切换。服务端方案会在运维上增加一些复杂度。\n  解决缓存穿透问题的2种最主要的解决方案   回种空值是一种最常见的解决思路，实现起来也最简单，如果评估空值缓存占据的缓存空间可以接受，那么可以优先使用这种方案；\n  布隆过滤器会引入一个新的组件，也会引入一些开发上的复杂度和运维上的成本。所以只有在存在海量查询数据库中，不存在数据的请求时才会使用，在使用时也要关注布隆过滤器对内存空间的消耗；\n  对于极热点缓存数据穿透造成的“狗桩效应”，可以通过设置分布式锁或者后台线程定时加载的方式来解决。\n  ","date":"2021-10-23T00:00:00Z","permalink":"https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/","title":"《重构第二版》笔记"},{"content":"何为线程？  线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n Java线程的生命周期  Java线程的生命周期——码艺术 \n 新建（New）：刚使用new方法，new出来的线程。 就绪（Runnable）：调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行。 运行（Running）：当就绪的线程被调度并获得CPU的资源时，便进入了运行状态，run方法定义了线程的功能。 阻塞（Blocked）：在运行状态的时候，可能因为某些原因导致运行状态的线程进入了阻塞状态，比如sleep()、wait()之后线程就变为阻塞状态，这个时候需要有其他机制将阻塞状态的线程唤醒，比如调用notify()或者notifyAll()方法，唤醒的线程不会立即执行run()方法，而是进入就绪状态（Runnable）状态，再次等待CPU分配资源进入运行状态。 销毁（Terminated）：如果线程正常执行完成后或线程被提前强制性终止、出现异常导致结束，那么线程就要被销毁并释放资源。  新建状态 Thread t1 = new Thread();\n这里的创建，仅仅是在JAVA的这种编程语言层面被创建，而在操作系统层面，真正的线程还没有被创建。只有当我们调用了 start() 方法之后，该线程才会被创建出来，进入Runnable状态。只有当我们调用了 start() 方法之后，该线程才会被创建出来。\n Java线程的新建状态——码艺术 \n就绪状态 t1.start()\n调用start()方法后，JVM 进程会去创建一个新的线程，而此线程不会马上被 CPU 调度运行，进入Running状态，这里会有一个中间状态，就是Runnable状态，可以理解为等待被 CPU 调度的状态。\n Java线程的就绪状态——码艺术 \nRunnable状态的线程无法直接进入Blocked状态和Terminated状态。只能进入Running状态的线程，换句话说，只有获得CPU调度执行权的线程才有资格进入Blocked状态和Terminated状态，Runnable状态的线程要么能被转换成Running状态，要么被意外终止。如下所示：\n Java线程的就绪状态转变——码艺术 \n运行状态 当CPU调度发生，并从任务队列中选中了某个Runnable线程时，该线程会进入Running执行状态，并且开始调用run()方法中逻辑代码。\n处于Running状态的线程能发生以下状态转变：\n 被转换成Terminated状态，比如调用 stop() 方法。 被转换成Blocked状态，比如调用了sleep(), wait() 方法被加入 waitSet 中。 被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态。 被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中。 该线程的时间片用完，CPU 再次调度，进入Runnable状态。 线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态。   Java线程的运行状态转变——码艺术 \n阻塞状态 Blocked状态的线程能够发生如下状态改变\n Java线程的阻塞状态转变——码艺术 \n 被转换成Terminated状态，比如调用 stop() 方法，或者是 JVM 意外 Crash。 被转换成Runnable状态，阻塞时间结束，如：读取到了数据库数据后。 完成了指定时间的休眠，进入到Runnable状态。 正在wait中的线程，被其他线程调用notify()、notifyAll()方法唤醒，进入到Runnable状态。 线程获取到了想要的锁资源，进入Runnable状态。 线程在阻塞状态下被打断，如其他线程调用了interrupt()方法，进入到Runnable状态。  终止状态 一旦线程进入了Terminated状态，就意味着这个线程生命的终结，哪些情况下，线程会进入到Terminated状态呢？\n 线程正常运行结束，生命周期结束。 线程运行过程中出现意外错误。 JVM 异常结束，所有的线程生命周期均被结束。  synchronized使用详解 synchronized关键字\n","date":"2021-08-23T00:00:00Z","permalink":"https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/","title":"Java多线程详解"}]