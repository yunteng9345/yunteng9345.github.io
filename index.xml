<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>码艺术</title>
        <link>https://yunteng9345.github.io/</link>
        <description>Recent content on 码艺术</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 04 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://yunteng9345.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>《金字塔原理》读书笔记</title>
        <link>https://yunteng9345.github.io/p/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Fri, 04 Nov 2022 00:00:00 +0000</pubDate>
        
        <guid>https://yunteng9345.github.io/p/%E9%87%91%E5%AD%97%E5%A1%94%E5%8E%9F%E7%90%86%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;金字塔原理&#34;&gt;金字塔原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第1篇 表达的逻辑&lt;/li&gt;
&lt;li&gt;第2篇 思考的逻辑&lt;/li&gt;
&lt;li&gt;第3篇 解决问题的逻辑&lt;/li&gt;
&lt;li&gt;第4篇 演示的逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对受众（包括读者、听众、观众或学员）来说，最容易理解的顺序是：先了解主要的、抽象的思想，然后了解次要的、为主要思想提供支持的思想。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>《MySQL是怎样运行的》笔记</title>
        <link>https://yunteng9345.github.io/p/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yunteng9345.github.io/p/mysql%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;mysql服务器处理客户端请求&#34;&gt;MySQL服务器处理客户端请求&lt;/h3&gt;
&lt;p&gt;客户端进程向服务端进程发送一段文本（MySQL语句），服务器处理后再向客户端发送一段文本（数据结果）&lt;/p&gt;
&lt;p&gt;mysql服务端处理流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接管理
&lt;ol&gt;
&lt;li&gt;处理连接&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;解析与优化
&lt;ol&gt;
&lt;li&gt;查询缓存&lt;/li&gt;
&lt;li&gt;语法解析&lt;/li&gt;
&lt;li&gt;查询优化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;存储引擎
&lt;ol&gt;
&lt;li&gt;MyISAM、InnoDB&lt;/li&gt;
&lt;li&gt;文件系统&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;innodb记录存储结构&#34;&gt;InnoDB记录存储结构&lt;/h3&gt;
&lt;p&gt;InnoDB将数据划分为&lt;strong&gt;若干个页&lt;/strong&gt;，以页（1页16KB）作为磁盘和内存之间交互的基本单位。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>《单元测试的艺术》笔记</title>
        <link>https://yunteng9345.github.io/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yunteng9345.github.io/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h2 id=&#34;优秀单元测试特性&#34;&gt;优秀单元测试特性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;他应该是自动化的，可重复执行&lt;/li&gt;
&lt;li&gt;他应该很容易实现&lt;/li&gt;
&lt;li&gt;他应该第二天还有意义&lt;/li&gt;
&lt;li&gt;任何人都应该一键运行他&lt;/li&gt;
&lt;li&gt;他应该运行速度很快&lt;/li&gt;
&lt;li&gt;他的结果应该是很稳定的（如果运行之间没有修改，多次运行一个测试应该返回相同的结果）&lt;/li&gt;
&lt;li&gt;他应该能完全控制被测试的单元&lt;/li&gt;
&lt;li&gt;他应该是完全隔离的（独立于其他测试的运行）&lt;/li&gt;
&lt;li&gt;如果他失败了，我们应该很容易发现什么是期待结果，进而定位问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;单元测试不等于集成测试&#34;&gt;单元测试不等于集成测试&lt;/h2&gt;
&lt;p&gt;任何测试，如果他运行不快，结果不稳定，或者用到被测试单元的一个或多个真实依赖物，我们就认为他是&lt;strong&gt;集成测试&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;单元测试也可以共用方法，使代码一目了然&lt;/p&gt;
&lt;h2 id=&#34;存根stub和模拟对象的区别&#34;&gt;存根（stub）和模拟对象的区别&lt;/h2&gt;
&lt;p&gt;存根是用来模拟各种场景的测试对象&lt;/p&gt;
&lt;h2 id=&#34;细节&#34;&gt;细节&lt;/h2&gt;
&lt;p&gt;测试过程中，如果一个断言失败了，那么不需要关心后面的断言&lt;/p&gt;
&lt;p&gt;单元测试，只做&lt;strong&gt;一件&lt;/strong&gt;事情&lt;/p&gt;
&lt;h2 id=&#34;mock&#34;&gt;Mock&lt;/h2&gt;
&lt;p&gt;Mocks are used as a replacement for a dependency.、&lt;/p&gt;
&lt;h2 id=&#34;断言注意&#34;&gt;断言注意&lt;/h2&gt;
&lt;p&gt;单元测试中不应该有多个断言，如果有的话，可分成2个单元测试。避免多个关注点&lt;/p&gt;
&lt;p&gt;覆盖率低于20%说明缺少很多测试&lt;/p&gt;
&lt;p&gt;断言中的&lt;strong&gt;魔法值&lt;/strong&gt;应该用常量的英文单词，可一眼看出预期。&lt;/p&gt;
&lt;p&gt;断言和操作分离&lt;/p&gt;
&lt;p&gt;单元测试失败的原因：要改变人的习惯，更多的是做出心理上的改变，而非技术上的。人们不喜欢改变，改变通常伴随着害怕、不确定和怀疑。&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 223; flex-basis: 535px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20211111152032834.png&#34; data-size=&#34;1029x461&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20211111152032834.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20211111152032834_hu2459bf03d2767477242276fa44b9df4b_143098_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF%E7%AC%94%E8%AE%B0/image-20211111152032834_hu2459bf03d2767477242276fa44b9df4b_143098_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;1029&#34;
				height=&#34;461&#34;
				loading=&#34;lazy&#34;
				alt=&#34;image-20211111152032834&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;image-20211111152032834&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;​					——摘自《单元测试的艺术》&lt;/p&gt;
&lt;p&gt;研究表明：大部分的缺陷并不是来自代码自身，而是由人们之间的误解、不断变化的需求以及缺少应用领域知识造成的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>《重构第二版》笔记</title>
        <link>https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h1 id=&#34;第1章重构第一个示例&#34;&gt;第1章——重构，第一个示例&lt;/h1&gt;
&lt;h2 id=&#34;思想&#34;&gt;思想&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;需求的变化使重构变得必要&lt;/p&gt;
&lt;p&gt;重构就是以微小的步伐修改程序，如果有问题，可立马发现&lt;/p&gt;
&lt;p&gt;傻瓜都能写出计算机可以理解的代码，唯有能写出人类容易理解的代码，才是优秀的程序员&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;步骤&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;重构前，检查自己是否有一套可靠的测试集，这些测试必须有自我检验的能力（&lt;strong&gt;单元测试&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;把复杂的代码分解为更小的单元&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;细节&#34;&gt;细节&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;将函数分割为单一功能，提炼到外部提供调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;改动完成之后，立马编译执行一遍单元测试，原因：&lt;strong&gt;在真的犯了错误时：只需要考虑一个很小的改动范围，使得排查与修复问题易如反掌&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;变量改名，使它们更加简洁&lt;/li&gt;
&lt;li&gt;处理结果变量时，将循环代码和变量放在一起，然后用查询函数取代临时变量&lt;/li&gt;
&lt;li&gt;利用多态取代条件表达式&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第2章重构的原则&#34;&gt;第2章——重构的原则&lt;/h1&gt;
&lt;h2 id=&#34;思想-1&#34;&gt;思想&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;重构的唯一目的就是让我们开发的更快，用更少的工作量创造更大的价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第2章——重构的原则&lt;/p&gt;
&lt;h1 id=&#34;第3章代码的坏味道&#34;&gt;第3章——代码的坏味道&lt;/h1&gt;
&lt;h2 id=&#34;思想-2&#34;&gt;思想&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;命名函数或变量，如果想不出一个好名字，说明背后很可能潜藏着更深的设计问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;步骤-1&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;规范注释，参照Spring源码&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;细节-1&#34;&gt;细节&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>《重构第二版》笔记</title>
        <link>https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;从古至今，长江和黄河流域水患不断，远古时期，大禹曾拓宽河道，清除淤沙让流水更加顺畅；都江堰作为史上最成功的的治水案例之一，用引流将岷江之水分流到多个支流中，以分担水流压力；三门峡和葛洲坝通过建造水库将水引入水库先存储起来，然后再想办法把水库中的水缓缓地排出去，以此提高下游的抗洪能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高并发的处理方式目前有三种方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Scale-out(横向扩展)：采用分布式部署的方式把流量分流开，让每个服务器都承担一部分并发和流量。&lt;/li&gt;
&lt;li&gt;缓存：使用缓存来提高系统的性能（空间换时间）&lt;/li&gt;
&lt;li&gt;异步：某些场景下，处理未完成的请求时，可以先让请求返回，数据准备好之后返回请求方。这样可以在单位时间内处理更多的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OSI 网络模型分层：物理层、数据链路层、   网络层、传输层、       会话层、表现层、应用层。&lt;/p&gt;
&lt;p&gt;TCP/IP 协议分层：            链路层、                网络层、传输层、                 应用层。&lt;/p&gt;
&lt;h2 id=&#34;高可用系统设计的思路&#34;&gt;高可用系统设计的思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;系统设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;failover机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超时调整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;降级、限流&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统运维&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;灰度发布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障演练&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可扩展性的设计思路&#34;&gt;高可扩展性的设计思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;拆分，将复杂问题简单化&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;1-存储层的扩展性&#34;&gt;1. 存储层的扩展性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;业务维度&lt;/li&gt;
&lt;li&gt;数据库维度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-业务层的扩展性&#34;&gt;2. 业务层的扩展性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;业务&lt;/li&gt;
&lt;li&gt;重要性&lt;/li&gt;
&lt;li&gt;请求来源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于数据库连接池，根据我的经验，一般在线上我建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可。&lt;/p&gt;
&lt;p&gt;java线程池学习（重要）&lt;/p&gt;
&lt;p&gt;在 4 核 8G 的机器上运 MySQL 5.7 时，大概可以支撑 500 的 TPS 和 10000 的 QPS&lt;/p&gt;
&lt;p&gt;Mysql主从复制&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 225; flex-basis: 541px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/16373226209384.png&#34; data-size=&#34;1142x506&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/16373226209384.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/16373226209384_huc469d2a88f644ae73d901c9e1c733b50_202791_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/16373226209384_huc469d2a88f644ae73d901c9e1c733b50_202791_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;1142&#34;
				height=&#34;506&#34;
				loading=&#34;lazy&#34;
				alt=&#34;img&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;img&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;主从同步过程：从库在连接到主节点时，会创建一个IO线程，用来请求主库的binlog。把接收到的binlog信息写入relay log的日志文件中。而主库也会创建一个log dump的线程来发送binlog给从库。同事，从库还会创建一个SQL线程读取relay log中的内容，然后做回放将信息写入从库。&lt;/p&gt;
&lt;p&gt;同步延迟导致短时间数据不一致问题处理方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据冗余（推荐使用，效率高）&lt;/li&gt;
&lt;li&gt;使用缓存&lt;/li&gt;
&lt;li&gt;查询主库&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;倒排索引&#34;&gt;倒排索引&lt;/h2&gt;
&lt;p&gt;倒排索引是指将记录中的某些列做分词，然后形成的分词与记录 ID 之间的映射关系。比如说，你的垂直电商项目里面有以下记录：&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 367; flex-basis: 881px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553123%281%29.jpg&#34; data-size=&#34;1142x311&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553123%281%29.jpg&#34;
				srcset=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553123%281%29_hufd9b35715f2f9137da2aa6dc9b55384f_73381_480x0_resize_q75_box.jpg 480w, https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553123%281%29_hufd9b35715f2f9137da2aa6dc9b55384f_73381_1024x0_resize_q75_box.jpg 1024w&#34;
				width=&#34;1142&#34;
				height=&#34;311&#34;
				loading=&#34;lazy&#34;
				alt=&#34;img&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;img&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;那么，我们将商品名称做简单的分词，然后建立起分词和商品 ID 的对应关系，就像下面展示的这样：&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 252; flex-basis: 606px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553177%281%29.jpg&#34; data-size=&#34;1142x452&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553177%281%29.jpg&#34;
				srcset=&#34;https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553177%281%29_hu0788671f7640a7bc61d8be2e211d93c4_79812_480x0_resize_q75_box.jpg 480w, https://yunteng9345.github.io/p/%E9%87%8D%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%89%88%E7%AC%94%E8%AE%B0/1637553177%281%29_hu0788671f7640a7bc61d8be2e211d93c4_79812_1024x0_resize_q75_box.jpg 1024w&#34;
				width=&#34;1142&#34;
				height=&#34;452&#34;
				loading=&#34;lazy&#34;
				alt=&#34;img&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;img&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;分布式缓存的高可用的3种主流方案&#34;&gt;分布式缓存的高可用的3种主流方案&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端方案，一般也称为 Smart Client。我们通过制定一些数据分片和数据读写的策略，可以实现缓存高可用。这种方案的好处是性能没有损耗，缺点是客户端逻辑复杂且在多语言环境下不能复用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间代理方案，在客户端和缓存节点之间增加了中间层，在性能上会有一些损耗，在代理层会有一些内置的高可用方案，比如 Codis 会使用 Codis Ha 或者 Sentinel。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端方案，依赖于组件的实现，Memcached 就只支持单机版没有分布式和 HA 的方案，而 Redis 在 2.4 版本提供了 Sentinel 方案可以自动进行主从切换。服务端方案会在运维上增加一些复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;解决缓存穿透问题的2种最主要的解决方案&#34;&gt;解决缓存穿透问题的2种最主要的解决方案&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;回种空值是一种最常见的解决思路，实现起来也最简单，如果评估空值缓存占据的缓存空间可以接受，那么可以优先使用这种方案；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布隆过滤器会引入一个新的组件，也会引入一些开发上的复杂度和运维上的成本。所以只有在存在海量查询数据库中，不存在数据的请求时才会使用，在使用时也要关注布隆过滤器对内存空间的消耗；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于极热点缓存数据穿透造成的“狗桩效应”，可以通过设置分布式锁或者后台线程定时加载的方式来解决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Java多线程详解</title>
        <link>https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate>
        
        <guid>https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/</guid>
        <description>&lt;h2 id=&#34;何为线程&#34;&gt;何为线程？&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;（thread）是操作系统能够进行运算调度的&lt;strong&gt;最小单位&lt;/strong&gt;。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;java线程的生命周期&#34;&gt;Java线程的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 238; flex-basis: 572px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle.png&#34; data-size=&#34;987x414&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_hu4ad4f12ae0117077ebdd61856154b6ab_47144_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_hu4ad4f12ae0117077ebdd61856154b6ab_47144_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;987&#34;
				height=&#34;414&#34;
				loading=&#34;lazy&#34;
				alt=&#34;Java线程的生命周期——码艺术&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Java线程的生命周期——码艺术&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新建（New）：刚使用new方法，new出来的线程。&lt;/li&gt;
&lt;li&gt;就绪（Runnable）：调用的线程的&lt;code&gt;start()&lt;/code&gt;方法后，这时候&lt;strong&gt;线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;运行（Running）：当就绪的线程被调度并获得CPU的资源时，便进入了运行状态，run方法定义了线程的功能。&lt;/li&gt;
&lt;li&gt;阻塞（Blocked）：在运行状态的时候，可能因为某些原因导致运行状态的线程进入了阻塞状态，比如&lt;code&gt;sleep()&lt;/code&gt;、&lt;code&gt;wait()&lt;/code&gt;之后线程就变为阻塞状态，这个时候需要有其他机制将阻塞状态的线程唤醒，比如调用&lt;code&gt;notify()&lt;/code&gt;或者&lt;code&gt;notifyAll()&lt;/code&gt;方法，&lt;strong&gt;唤醒的线程不会立即执行&lt;code&gt;run()&lt;/code&gt;方法&lt;/strong&gt;，而是进入就绪状态（Runnable）状态，再次等待CPU分配资源进入运行状态。&lt;/li&gt;
&lt;li&gt;销毁（Terminated）：如果线程正常执行完成后或线程被提前强制性终止、出现异常导致结束，那么线程就要被销毁并释放资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;新建状态&#34;&gt;新建状态&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Thread t1 = new Thread();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里的创建，仅仅是在JAVA的这种编程语言层面被创建，而在操作系统层面，真正的线程还没有被创建。只有当我们调用了 start() 方法之后，该线程才会被创建出来，进入Runnable状态。只有当我们调用了 &lt;code&gt;start()&lt;/code&gt; 方法之后，该线程才会被创建出来。&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 181; flex-basis: 434px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_new.png&#34; data-size=&#34;413x228&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_new.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_new_hu1c672cb809a2075a685dc18510c863be_12197_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_new_hu1c672cb809a2075a685dc18510c863be_12197_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;413&#34;
				height=&#34;228&#34;
				loading=&#34;lazy&#34;
				alt=&#34;Java线程的新建状态——码艺术&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Java线程的新建状态——码艺术&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;就绪状态&#34;&gt;就绪状态&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;t1.start()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;start()&lt;/code&gt;方法后，JVM 进程会去创建一个新的线程，而此线程不会马上被 CPU 调度运行，进入Running状态，这里会有一个中间状态，就是Runnable状态，可以理解为等待被 CPU 调度的状态。&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 170; flex-basis: 409px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable.png&#34; data-size=&#34;646x379&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable_hu48234fc21a75f040428eed58c31fc500_28697_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable_hu48234fc21a75f040428eed58c31fc500_28697_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;646&#34;
				height=&#34;379&#34;
				loading=&#34;lazy&#34;
				alt=&#34;Java线程的就绪状态——码艺术&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Java线程的就绪状态——码艺术&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Runnable状态的线程&lt;strong&gt;无法直接进入Blocked状态和Terminated状态&lt;/strong&gt;。只能进入Running状态的线程，换句话说，只有获得CPU调度执行权的线程才有资格进入Blocked状态和Terminated状态，Runnable状态的线程要么能被转换成Running状态，要么被意外终止。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 206; flex-basis: 495px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable2status.png&#34; data-size=&#34;659x319&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable2status.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable2status_huf107e3cd710efc09f5bbb2e1975be0e0_21051_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_runnable2status_huf107e3cd710efc09f5bbb2e1975be0e0_21051_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;659&#34;
				height=&#34;319&#34;
				loading=&#34;lazy&#34;
				alt=&#34;Java线程的就绪状态转变——码艺术&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Java线程的就绪状态转变——码艺术&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;运行状态&#34;&gt;运行状态&lt;/h2&gt;
&lt;p&gt;当CPU调度发生，并从任务队列中选中了某个Runnable线程时，该线程会进入Running执行状态，并且开始调用run()方法中逻辑代码。&lt;/p&gt;
&lt;p&gt;处于Running状态的线程能发生以下状态转变：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被转换成Terminated状态，比如调用 &lt;code&gt;stop()&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;被转换成Blocked状态，比如调用了&lt;code&gt;sleep()&lt;/code&gt;, &lt;code&gt;wait()&lt;/code&gt; 方法被加入 waitSet 中。&lt;/li&gt;
&lt;li&gt;被转换成Blocked状态，如进行 IO 阻塞操作，如查询数据库进入阻塞状态。&lt;/li&gt;
&lt;li&gt;被转换成Blocked状态，比如获取某个锁的释放，而被加入该锁的阻塞队列中。&lt;/li&gt;
&lt;li&gt;该线程的时间片用完，CPU 再次调度，进入Runnable状态。&lt;/li&gt;
&lt;li&gt;线程主动调用 yield 方法，让出 CPU 资源，进入Runnable状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 106; flex-basis: 255px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_running2status.png&#34; data-size=&#34;466x438&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_running2status.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_running2status_hu367a75e1a48d33ad76a4e8a7d21d6bae_24277_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_running2status_hu367a75e1a48d33ad76a4e8a7d21d6bae_24277_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;466&#34;
				height=&#34;438&#34;
				loading=&#34;lazy&#34;
				alt=&#34;Java线程的运行状态转变——码艺术&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Java线程的运行状态转变——码艺术&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;阻塞状态&#34;&gt;阻塞状态&lt;/h2&gt;
&lt;p&gt;Blocked状态的线程能够发生如下状态改变&lt;/p&gt;
&lt;p&gt;&lt;figure style=&#34;flex-grow: 145; flex-basis: 348px&#34;&gt;
		&lt;a href=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_blocked2status.png&#34; data-size=&#34;458x315&#34;&gt;&lt;img src=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_blocked2status.png&#34;
				srcset=&#34;https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_blocked2status_hueb6594c63b47f5b5cc909a6b4311819b_17897_480x0_resize_box_3.png 480w, https://yunteng9345.github.io/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/threadLifeCycle_blocked2status_hueb6594c63b47f5b5cc909a6b4311819b_17897_1024x0_resize_box_3.png 1024w&#34;
				width=&#34;458&#34;
				height=&#34;315&#34;
				loading=&#34;lazy&#34;
				alt=&#34;Java线程的阻塞状态转变——码艺术&#34;&gt;
		&lt;/a&gt;
		
		&lt;figcaption&gt;Java线程的阻塞状态转变——码艺术&lt;/figcaption&gt;
		
	&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被转换成Terminated状态，比如调用 &lt;code&gt;stop()&lt;/code&gt; 方法，或者是 JVM 意外 Crash。&lt;/li&gt;
&lt;li&gt;被转换成Runnable状态，阻塞时间结束，如：读取到了数据库数据后。&lt;/li&gt;
&lt;li&gt;完成了指定时间的休眠，进入到Runnable状态。&lt;/li&gt;
&lt;li&gt;正在wait中的线程，被其他线程调用&lt;code&gt;notify()&lt;/code&gt;、&lt;code&gt;notifyAll()&lt;/code&gt;方法唤醒，进入到Runnable状态。&lt;/li&gt;
&lt;li&gt;线程获取到了想要的锁资源，进入Runnable状态。&lt;/li&gt;
&lt;li&gt;线程在阻塞状态下被打断，如其他线程调用了&lt;code&gt;interrupt()&lt;/code&gt;方法，进入到Runnable状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;终止状态&#34;&gt;终止状态&lt;/h2&gt;
&lt;p&gt;一旦线程进入了Terminated状态，就意味着这个线程生命的终结，哪些情况下，线程会进入到Terminated状态呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程正常运行结束，生命周期结束。&lt;/li&gt;
&lt;li&gt;线程运行过程中出现意外错误。&lt;/li&gt;
&lt;li&gt;JVM 异常结束，所有的线程生命周期均被结束。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;synchronized使用详解&#34;&gt;synchronized使用详解&lt;/h2&gt;
&lt;p&gt;synchronized关键字&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
